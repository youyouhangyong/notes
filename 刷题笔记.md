## 第一天

### [704. 二分查找](https://leetcode.cn/problems/binary-search/)

```
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
```

```c++
int search(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}

```

```
在此实现中，我们将两个指针 left 和 right 初始化为 nums 向量的开始和结尾，分别表示当前要查找的子数组的左右端点。
然后，我们重复计算 left 和 right 之间的中点 mid，并将 nums[mid] 与 target 元素进行比较。
如果 nums[mid] 等于 target，则返回索引 mid。
否则，如果 nums[mid] 小于 target，则将 left = mid + 1，以在子数组的右半部分中查找 target。
同样，如果 nums[mid] 大于 target，则将 right = mid - 1，以在子数组的左半部分中查找 target。
我们继续这个过程，直到我们找到 target 元素或 left 超过了 right，这表明 nums 向量中不存在 target 元素。
在后一种情况下，我们返回 -1，以表示未找到 target 元素。
```

### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

```
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
```

```c++
int removeElement(vector<int>& nums, int val) {
    int i = 0;
    for (int j = 0; j < nums.size(); j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
 }

```

```
使用双指针，一个指针指向数组的当前元素，另一个指针指向当前要删除的元素的位置。
如果当前元素不等于给定值val，则将该元素复制到第二个指针所指向的位置，并将第二个指针向后移动一个位置。
最后返回第二个指针所指向的位置，即为删除给定值val后数组的新长度。
```

### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
```

```c++
vector<int> sortedSquares(vector<int>& nums) {
        int n=nums.size();
        vector<int> result(n);//可以使用 vector 类型来动态分配内存
        int left = 0,right = n-1;
        int index = n-1;
        while(left<=right){
            if(nums[left]*nums[left]>nums[right]*nums[right]){
                result[index]=nums[left]*nums[left];//第一次存入result的最后一个位置
                left++;
            }else{
                result[index]=nums[right]*nums[right];
                right--;
            }
            index--;
        }
        return result;
    }
```

```
使用双指针法，首先，我们可以将原数组中的每个数平方，然后再按照非递减顺序排序。
由于数组已经按照非递减顺序排好序了，
我们可以使用两个指针分别指向数组的最左端和最右端。
比较两个指针所指向的数的平方值，将较大的那个放入新数组的末尾。
移动指针时，需要判断指针所指向的数是否已经被加入了新数组中，如果已经被加入了，则需要跳过。
```

## 第二天


### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```

```c++
int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
```

```
该函数采用滑动窗口算法，使用两个指针 i 和 j 表示滑动窗口的左右边界，
用变量 sum 表示滑动窗口内的元素之和，用变量 subLength 表示当前符合条件的子数组的长度，用变量 result 表示最终的结果。
遍历数组 'nums'，不断将元素添加到滑动窗口中，当滑动窗口内元素之和 sum 大于或等于给定整数 's' 时，
通过不断移动指针 i 来缩小滑动窗口的大小，同时更新变量 subLength 和 result，
最终返回 result 的值。 如果不存在符合条件的子数组，则返回 0。
```

### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。
```

```c++
int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right){
            int mid = (left + right) / 2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid]<target){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return left;
    }
```

```
首先，判断目标值是否在数组中存在，如果存在，返回它的索引。
如果目标值不在数组中，可以通过二分查找找到它应该被插入的位置。
具体来说，可以使用两个指针 left 和 right 分别指向数组的起始和结束位置。
然后，计算它们的中间位置 mid，并将目标值与 nums[mid] 进行比较。
如果目标值小于 nums[mid]，则将 right 指针移动到 mid - 1 的位置；
如果目标值大于 nums[mid]，则将 left 指针移动到 mid + 1 的位置。重复以上步骤，直到找到目标值或者 left > right。
如果找不到目标值，最后 left 的位置就是目标值应该被插入的位置。
```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftBor =getLeft(nums ,target);
        int rightBor =getRight(nums,target);
        if(leftBor== -2||rightBor== -2)return {-1,-1};
        if(rightBor-leftBor>1)return{leftBor+1,rightBor-1};
        return {-1,-1};
    }
    private:
        int getRight(vector<int>&nums,int target){
            int left =0 ;
            int right =nums.size()-1;
            int rightBor=-2;
            while(left<=right){
                int mid = left+((right-left)/2);
                if(nums[mid]>target){
                    right = mid-1;
                }else{
                    left=mid+1;
                    rightBor =left;
                }
            }
            return rightBor;
        }
        int getLeft(vector<int>&nums,int target){
            int left =0 ;
            int right =nums.size()-1;
            int leftBor=-2;
            while(left<=right){
                int mid = left+((right-left)/2);
                if(nums[mid]>=target){
                    right=mid-1;
                    leftBor = right;
                }else{
                    left=mid+1;
                }
            }
            return leftBor;
        }
};
```

```
可以编写两个函数 getRight() 和 getLeft()，它们分别用于查找目标值在数组中第一次和最后一次出现的位置。
在这两个函数中，我们使用二分查找来搜索目标值，
当找到目标值时，我们会记录它的位置，并继续在左半部分或右半部分中搜索，
直到找到最后一个目标值出现的位置。如果目标值不存在于数组中，则返回 [-1, -1]。
```

代码可以进行简化

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size();
        int left = findBound(nums, n, target, true);
        int right = findBound(nums, n, target, false);
        if (left <= right) {
            return {left, right};
        } else {
            return {-1, -1};
        }
    }

private:
    int findBound(vector<int>& nums, int n, int target, bool isLeft) {
        int left = 0, right = n - 1;
        int res = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                res = mid;
                if (isLeft) right = mid - 1;
                else left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return res;
    }
};

```

```
可以将 findFirst() 和 findLast() 合并为一个函数，
并使用一个额外的参数 isLeft 来指示我们是在查找目标值的第一次出现位置还是最后一次出现位置。
在这个函数中，我们也使用二分查找算法来搜索目标值，并在找到目标值时更新左右指针。
当找到目标值时，我们可以根据参数 isLeft 来更新左右指针，以便在正确的半边继续查找。
在 searchRange() 函数中，我们先调用 findBound() 找到目标值的第一个位置，然后再次调用 findBound() 找到目标值的最后一个位置。
如果第一个位置小于等于最后一个位置，则返回结果区间 [left, right]；否则，返回 [-1, -1]，表示未找到目标值。
```

### [69. x 的平方根](https://leetcode.cn/problems/sqrtx/)

思路来自[BV1Qe411P7rs](https://www.bilibili.com/video/BV1Qe411P7rs/?spm_id_from=333.337.search-card.all.click&vd_source=a7dd7e2ac79efdb10cc027f8d64f3d6d)

> **exp函数+精度修正**
>
> ```c++
> class Solution {
> public:
>     int mySqrt(int x) {
>         return (int)( exp(log(x)/2)+1e-8);
>     }
> };
> ```
>
> 会导致不同平台精度不一致

>**暴击枚举**
>
>```c++
>class Solution {
>public:
>    int mySqrt(int x) {
>        for(int i=0;;i++){
>            if(i*i>x){
>                return i-1;
>            }
>        }
>    }
>};
>```
>
>时间复杂度高，并且会出现溢出

> **牛顿迭代**
>
> ```c++
> class Solution {
> public:
>     int mySqrt(int n) {
>         double x0,x1;
>         x1=12;
>         do{
>             x0=x1;
>             double v= f(x0,n);
>            x1=-v/(x0*2)+x0;
>         }while(fabs(x0-x1)>1e-8);
>         int ans =(int)(x0+1e-8);
>         if(ans*ans>n) --ans;
>         return ans;
>     }
>     private:
>     double f(double x,int n){
>         return x*x-n;
>     }
> };
> ```

>**二进制枚举**
>
>```c++
>class Solution {
>public:
>    int mySqrt(int x) {
>        if (x <= 1) return x;
>        int left = 0, right = x / 2 + 1;
>        while (left < right) {
>            int mid = left + (right - left + 1) / 2;
>            if ((long long)mid * mid <= x) left = mid;
>            else right = mid - 1;
>        }
>        return left;
>    }
>}
>```
>
>```
>在实现中，我们采用了类似于二分查找的方式，将左右边界不断缩小，直到左右边界重合或相邻。在每次查找时，我们将中间值 mid 的平方与 x 进行比较，然后根据比较结果更新左右边界。由于我们要求的是整数平方根，因此中间值 mid 应该取右中位数，即 (left + right + 1) / 2。
>需要注意的是，由于我们在比较 mid 的平方与 x 的大小时可能会溢出，因此我们需要将 mid 和 x 都转换为长整型进行计算。此外，在判断边界条件时，需要特判 x=0 和 x=1 的情况。
>```

一般情况下，二进制迭代法求整数平方根的时间复杂度为 $O(\log \log n)$，而牛顿迭代法的时间复杂度为 $O(\log n)$。因此，当 $n$ 的位数较大时，牛顿迭代法的速度会更快。

不过需要注意的是，牛顿迭代法的实现需要考虑到数值误差的问题，因此在具体实现时需要做出一些额外的处理，例如使用 long long 类型来存储变量，以避免整数溢出

## 第三天

### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

```
给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如  sqrt 。
```

```c++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int i = 1;
        while(num>0){
            num -= i;
            i += 2;
        }
        return num == 0;
    }
};
```

```
使用了一个递增的序列来不断减去输入的数字num，如果最终num等于0，说明输入的数字是完全平方数。
```

### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

```
你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

1.你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
2.你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
3.一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。
```

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int ans =0;
        unordered_map<int ,int> cnt;
        for(int i=0,j=0,s=0;i<fruits.size();i++){
            if(++cnt[fruits[i]]==1)//当遇到一个新水果时，将其加入哈希表中
                s++;//那么篮子中水果种类数s就要加1
            while(s>2)//如果水果种类超过2
            {
                if(-- cnt[fruits[j]]==0)
                {
                    s--;
                }
                j++;
            }
            ans =max(ans,i-j+1);
        }
        return ans;;
    }
};
```

```
具体的实现思路是：

1.定义一个哈希表 cnt，用来记录当前区间内不同水果的数量。
2.遍历 fruits 数组，当遇到一个新水果时，将其加入哈希表中，并将不同水果数量 s 加1。
3.如果当前区间内不同水果数量超过 2，说明要将区间缩小，此时需要将左端点 j 右移，并从哈希表中移除对应的水果。如果移除该水果后，当前区间内该种水果数量为 0，则将不同水果数量 s 减1。
4.在区间缩小的过程中，记录下每一次区间的长度，取最大值作为答案。

这个算法的时间复杂度为 O(n)，其中 n 是 fruits 数组的长度。
```

## 第四天

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
注意：
对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
示例：
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```



```c++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) {
            need[c]++;
        }
        int left = 0, right = 0;
        int valid = 0;
        int start = 0, len = INT_MAX;

        while (right < s.size()) {
            char c = s[right];
            right++;

            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c]) {
                    valid++;
                }
            }
            while (valid == need.size()) {
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                char d = s[left];
                left++;

                if (need.count(d)) {
                    if (window[d] == need[d]) {
                        valid--;
                    }
                    window[d]--;
                }
            }
        }
        return len == INT_MAX ? "" : s.substr(start, len);
    }
};

```

```
其中，need 是需要匹配的字符的计数表，window 是当前窗口中的字符计数表。valid 记录窗口中已经匹配的字符数。start 和 len 记录最小窗口的起始位置和长度。

具体实现过程如下：

1.初始化 need 计数表，其中将 t 中的每个字符计数；
2.初始化窗口左右指针 left 和 right 为 0，valid 为 0；
3.在右指针小于字符串 s 的长度的条件下，逐步增加右指针 right；
4.当右指针指向的字符是需要匹配的字符时，更新窗口中该字符的计数 window[c]，并判断当前窗口是否已经匹配了一个字符 valid；
5.当窗口中已经匹配了所有需要匹配的字符时，记录当前最小的窗口起始位置和长度 start 和 len；
6.在窗口已经匹配所有需要匹配的字符的条件下，逐步增加左指针 left；
7.当左指针指向的字符是需要匹配的字符时，更新窗口中该字符的计数 window[d]，并判断当前窗口是否仍然匹配了一个字符 valid；
8.重复步骤 3~7，直到右指针指向字符串 s 的末尾。
最后，如果存在最小窗口，则返回其对应的子串；否则返回空串。
```

### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

```
给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
```

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> matrix(n, vector<int>(n)); // 定义n * n矩阵，初始化为0
        int left = 0, right = n - 1, top = 0, bottom = n - 1; // 初始化边界
        int num = 1; // 初始化填充数字为1
        while (left <= right && top <= bottom) {
            for (int i = left; i <= right; i++)
                matrix[top][i] = num++; // 从左到右
            for (int i = top + 1; i <= bottom; i++)
                matrix[i][right] = num++; // 从上到下
            if (left < right && top < bottom) { // 防止重复
                for (int i = right - 1; i > left; i--) 
                    matrix[bottom][i] = num++; // 从右到左
                for (int i = bottom; i > top; i--)
                    matrix[i][left] = num++; // 从下到上
            }
            left++; right--; top++; bottom--; // 更新边界
        }
        return matrix;
    }
};

```

```
首先定义一个n * n的矩阵，初始化为0，然后模拟螺旋填充数字的过程。对于当前矩阵的四个边界（左、右、上、下），分别按照从左到右、从上到下、从右到左、从下到上的顺序填充数字，直到所有数字都被填充完为止。同时，不断更新矩阵的边界，防止重复填充数字。最后返回填充好的矩阵即可。
```

## 第五天

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
```

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;  // 定义结果数组
        if (matrix.empty()) {  // 如果矩阵为空，则直接返回结果数组
            return res;
        }
        int m = matrix.size(), n = matrix[0].size();  // 获取矩阵的行数和列数
        int left = 0, right = n - 1, top = 0, bottom = m - 1;  // 定义左、右、上、下边界
        while (left <= right && top <= bottom) {  // 只要还有元素需要遍历，就继续进行循环
            for (int j = left; j <= right; j++) {  // 从左到右遍历上边界
                res.push_back(matrix[top][j]);  // 将遍历到的元素加入结果数组中
            }
            for (int i = top + 1; i <= bottom; i++) {  // 从上到下遍历右边界
                res.push_back(matrix[i][right]);  // 将遍历到的元素加入结果数组中
            }
            if (left < right && top < bottom) {  // 如果当前矩阵的左边界小于右边界，并且上边界小于下边界
                for (int j = right - 1; j >= left; j--) {  // 从右到左遍历下边界
                    res.push_back(matrix[bottom][j]);  // 将遍历到的元素加入结果数组中
                }
                for (int i = bottom - 1; i > top; i--) {  // 从下到上遍历左边界
                    res.push_back(matrix[i][left]);  // 将遍历到的元素加入结果数组中
                }
            }
            left++;  // 更新左边界
            right--;  // 更新右边界
            top++;  // 更新上边界
            bottom--;  // 更新下边界
        }
        return res;  // 返回结果数组
    }
};
```

```
1.定义四个变量 left、right、top、bottom，分别表示当前要遍历的矩阵的左边界、右边界、上边界、下边界。
2.按照以下顺序遍历矩阵，并将遍历的元素按照顺序存入结果数组中：
	1.从左到右遍历上边界，将上边界上的元素加入结果数组中。
	2.从上到下遍历右边界，将右边界上的元素加入结果数组中。
	3.如果当前矩阵的左边界小于右边界，并且上边界小于下边界，则从右到左遍历下边界，将下边界上的元素加入结果数组中。
	4.如果当前矩阵的上边界小于下边界，并且左边界小于右边界，则从下到上遍历左边界，将左边界上的元素加入结果数组中。
	5.更新左、右、上、下边界的值，继续进行下一轮遍历，直到遍历完整个矩阵。
```

### [剑指 Offer 29. 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

```
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
```

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;  // 定义结果数组
        if (matrix.empty()) {  // 如果矩阵为空，则直接返回结果数组
            return res;
        }
        int m = matrix.size(), n = matrix[0].size();  // 获取矩阵的行数和列数
        int left = 0, right = n - 1, top = 0, bottom = m - 1;  // 定义左、右、上、下边界
        while (left <= right && top <= bottom) {  // 只要还有元素需要遍历，就继续进行循环
            for (int j = left; j <= right; j++) {  // 从左到右遍历上边界
                res.push_back(matrix[top][j]);  // 将遍历到的元素加入结果数组中
            }
            for (int i = top + 1; i <= bottom; i++) {  // 从上到下遍历右边界
                res.push_back(matrix[i][right]);  // 将遍历到的元素加入结果数组中
            }
            if (left < right && top < bottom) {  // 如果当前矩阵的左边界小于右边界，并且上边界小于下边界
                for (int j = right - 1; j >= left; j--) {  // 从右到左遍历下边界
                    res.push_back(matrix[bottom][j]);  // 将遍历到的元素加入结果数组中
                }
                for (int i = bottom - 1; i > top; i--) {  // 从下到上遍历左边界
                    res.push_back(matrix[i][left]);  // 将遍历到的元素加入结果数组中
                }
            }
            left++;  // 更新左边界
            right--;  // 更新右边界
            top++;  // 更新上边界
            bottom--;  // 更新下边界
        }
        return res;  // 返回结果数组
    }
};
```

```
思路与上题相同，不再赘述
```

## 第五天

### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

```
给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummy = new ListNode(0);  // 定义虚拟头节点，方便处理头节点就是待删除节点的情况
        dummy->next = head;  // 将虚拟头节点连接到真正的头节点之前
        ListNode* cur = dummy;  // 定义当前节点指针，初始指向虚拟头节点
        while (cur->next) {  // 只要当前节点后面还有节点，就继续遍历
            if (cur->next->val == val) {  // 如果当前节点的下一个节点值为 val，则将其删除
                ListNode* temp = cur->next;  // 定义临时节点指针，指向需要删除的节点
                cur->next = cur->next->next;  // 将当前节点指向下一个节点的下一个节点
                delete temp;  // 释放需要删除的节点
            } else {  // 如果当前节点的下一个节点值不为 val，则将当前节点指向下一个节点
                cur = cur->next;
            }
        }
        ListNode* newHead = dummy->next;  // 将新的头节点指向虚拟头节点的下一个节点
        delete dummy;  // 释放虚拟头节点
        return newHead;  // 返回新的头节点
    }
};

```

```
主要思路是使用虚拟头节点来简化删除头节点的操作，并使用当前节点指针来遍历链表，对节点值为 val 的节点进行删除操作。
需要注意的是，当所有节点都是待删除节点时，需要保证代码的正确性，避免出现野指针等错误。
```

## 第六天

### [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

```
你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。

实现 MyLinkedList 类：

1.MyLinkedList() 初始化 MyLinkedList 对象。
2.int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。
3.void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
4.void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。
5.void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。
6.void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。
```

```c++
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--){ // 如果--index 就会陷入死循环
            cur = cur->next;
        }
        return cur->val;
    }

    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 在链表最后面添加一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度，则返回空
    // 如果index小于0，则在头部插入节点
    void addAtIndex(int index, int val) {

        if(index > _size) return;
        if(index < 0) index = 0;        
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        //delete命令指示释放了tmp指针原本所指的那部分内存，
        //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，
        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针
        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间
        tmp=nullptr;
        _size--;
    }

    // 打印链表
    void printLinkedList() {
        LinkedNode* cur = _dummyHead;
        while (cur->next != nullptr) {
            cout << cur->next->val << " ";
            cur = cur->next;
        }
        cout << endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;
};
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        ListNode* prev = nullptr;
        ListNode* curr = head;
        ListNode* next = nullptr;
        while (curr != nullptr) {
            next = curr->next;  // 暂存当前节点的下一个节点
            curr->next = prev;  // 反转当前节点的指针指向前一个节点
            prev = curr;        // 更新前一个节点
            curr = next;        // 更新当前节点
        }
        return prev;  // 返回反转后的头节点
    }
};

```

```
1.初始化三个指针变量，分别指向前一个节点、当前节点和下一个节点，
	初始时前一个节点指向空，当前节点指向头节点，下一个节点指向空；
2.对于当前节点，将它的指针指向前一个节点，
	然后更新前一个节点为当前节点，当前节点为下一个节点；
3.重复上述步骤，直到当前节点为nullptr，
	此时反转完成，返回前一个节点即为反转后的头节点。
```

## 第七天

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。
你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0);  // 创建虚拟头节点，方便处理头节点
        dummyHead->next=head;  // 将虚拟头节点指向原头节点
        ListNode* cur =dummyHead;  // cur指针初始化为虚拟头节点，方便遍历链表
        while(cur->next!=nullptr&&cur->next->next!=nullptr){  // 当前节点和下一个节点都不为空时进行交换操作
            ListNode* temp= cur->next;  // 保存当前节点
            ListNode* temp1= cur->next->next->next;  // 保存下一个节点的下一个节点

            cur->next=cur->next->next;  // 当前节点指向下一个节点
            cur->next->next=temp;  // 下一个节点指向当前节点
            cur->next->next->next=temp1;  // 当前节点指向下一个节点的下一个节点

            cur=cur->next->next;  // cur指向交换后的下一个节点，继续遍历链表
        }
        return dummyHead->next;  // 返回交换后的链表
    }
};

```

```
1.创建一个虚拟头节点，指向原链表的头节点，方便处理头节点；
2.初始化一个cur指针，指向虚拟头节点，方便遍历链表；
3.遍历链表，当当前节点和下一个节点都不为空时，进行交换操作；
4.交换操作分别是：保存当前节点和下一个节点的下一个节点，将当前节点指向下一个节点，
下一个节点指向当前节点，当前节点指向下一个节点的下一个节点；
5.更新cur指针，指向交换后的下一个节点；
6.返回交换后的链表。
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
提示：
双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 创建虚拟头节点
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        // 创建快慢指针，初始都指向虚拟头节点
        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;
        // 让快指针先走n步
        while (n-- && fast != nullptr) {
            fast = fast->next;
        }
        // 让快指针再提前走一步，因为需要让慢指针指向删除节点的上一个节点
        fast = fast->next;
        // 快慢指针一起走，直到快指针到达链表尾部
        while (fast != nullptr) {
            fast = fast->next;
            slow = slow->next;
        }
        // 删除节点
        slow->next = slow->next->next;
        // 返回头节点
        return dummyHead->next;
    }
};

```

```
这道题目要求我们删除链表的倒数第 n 个结点。
首先我们可以使用双指针来解决这个问题。我们定义两个指针 slow 和 fast，
先让 fast 走 n 步，然后让 slow 和 fast 同时走，
当 fast 走到链表的尾部时，slow 就指向了倒数第 n 个结点的前一个节点，
此时我们可以删除 slow 指向的节点的下一个节点，即倒数第 n 个节点。

为了避免出现删除头节点的情况，我们可以使用虚拟头节点来处理。
我们可以先创建一个值为 0 的虚拟头节点 dummyHead，将它的下一个节点指向链表的头节点 head，
这样就能够处理掉删除头节点的情况了。最后返回 dummyHead 的下一个节点即可。
```

### [2235. 两整数相加](https://leetcode.cn/problems/add-two-integers/)

```
给你两个整数 num1 和 num2，返回这两个整数的和。
```

```c++
class Solution {
public:
    int sum(int num1, int num2) {
        return num1+num2;
    }
};
```

```
整活 😎
```

## 第八天

### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

```
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：

题目数据保证整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。
```

![image-20230417205509519](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230417205509519.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA; //定义两个指针指向headA和headB
        ListNode* curB = headB;
        
        int lenA= 0,lenB=0;//初始化，由于存储链表长度

        while(curA !=NULL){// 获取headA的长度
            lenA++;
            curA= curA->next;
        }
        while(curB!=NULL){// 获取headB的长度
            lenB++;
            curB= curB->next;
        }

        curA = headA;
        curB = headB;//重新将curA和curB指向链表的头部

        if(lenB>lenA){//如果链表B的长度大于链表A的长度
            swap(lenA,lenB);
            swap(curA,curB);//就将两个链表交换
        }

        int g= lenA-lenB;//计算长度差值
        
        while(g--){//把链表长度长的（就是curA）向后移动g位
            curA =curA->next;
        }

        while(curA != NULL){//再循环对比两个链表余下的部分
            if(curA==curB)return curA;//如果节点地址相同则返回地址
            curA =curA->next;
            curB= curB->next;//否则同时向后移动
        }
	return NULL;//没有相交节点，返回NULL
    }
};
```

```
简单来说，就是求两个链表交点节点的指针。
这里要注意，交点不是数值相等，而是指针相等。
我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置。
此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，
如果遇到curA == curB，则找到交点。
否则循环退出返回空指针。
```

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```
给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;//定义两个指针，都指向head
        ListNode* slow =head;
        while(fast!=NULL&& fast->next!=NULL){
            slow= slow->next;//slow走一步
            fast= fast->next->next;//fast走两步
            if(slow==fast){//相遇了
                ListNode* i1 =fast;//重新创建一个指针指向fast,也就是相遇的位置
                ListNode* i2 =head;//将另一个指针指向头节点
                while(i1!=i2){//一直循环到再次相遇
                    i1=i1->next;
                    i2=i2->next;
                }
                return i2;//相遇的地方就是环的入口
            }
        }
        return NULL;//没有环
    }
};
```
[思路在这]([leetcode-master/0142.环形链表II.md at master · youngyangyang04/leetcode-master (github.com)](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0142.环形链表II.md))

## 第九天

### 水一天，没刷题，这是今天的作业

```
实现了二叉树递归的前中后序遍历和对应的非递归遍历
```

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
// 二叉树链式存储结构体
typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
} BinaryNode, * BinaryTree;

// 初始化二叉树
void init(BinaryTree* t) {
    *t = NULL;
}

// 创建新节点
BinaryNode* createNode(int x) {
    BinaryNode* node = (BinaryNode*)malloc(sizeof(BinaryNode));
    node->data = x;
    node->left = node->right = NULL;
    return node;
}

// 通过先序遍历序列构建二叉树
void build(BinaryTree* t) {
    int x;
    scanf_s("%d", &x);
    if (x == -1) {  // 当前节点为NULL
        *t = NULL;
    }
    else {  // 当前节点不为NULL
        BinaryNode* node = createNode(x);
        *t = node;
        build(&(node->left));  // 递归构建左子树
        build(&(node->right));  // 递归构建右子树
    }
}

// 递归实现的前序遍历
void preRecursionTraversal(BinaryTree t) {
    if (t != NULL) {
        printf("%d ", t->data);
        preRecursionTraversal(t->left);
        preRecursionTraversal(t->right);
    }
}
// 递归实现的中序遍历
void midRecursionTraversal(BinaryTree t) {
    if (t != NULL) {
        midRecursionTraversal(t->left);
        printf("%d ", t->data);
        midRecursionTraversal(t->right);
    }
}
// 递归实现的后序遍历
void postRecursionTraversal(BinaryTree t) {
    if (t != NULL) {
        postRecursionTraversal(t->left);
        postRecursionTraversal(t->right);
        printf("%d ", t->data);
    }
}

// 非递归实现的前序遍历
//前序遍历是中左右，每次先处理的是中间节点
//先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子
void preOrderTraversal(BinaryTree t) {
    if (t == NULL) {
        return;
    }

    BinaryNode* stack[MAX_SIZE];  // 使用栈来保存节点
    int top = 0;

    stack[top++] = t;//将根节点压入
    while (top > 0) {//只要栈不为空，就继续循环
        BinaryNode* node = stack[--top];//取出顶部节点(中)
        printf("%d ", node->data);//打印操作

        // 先将右子树入栈，再将左子树入栈，保证左子树先遍历
        if (node->right != NULL) {//如果右不为NULL(右)
            stack[top++] = node->right;//压入栈顶
        }
        if (node->left != NULL) {//如果右不为NULL(左)
            stack[top++] = node->left;//压入栈顶
        }
    }
}

// 非递归实现的中序遍历
void midOrderTraversal(BinaryTree t) {
    if (t == NULL) {
        return;
    }

    BinaryNode* stack[MAX_SIZE];  // 使用栈来保存节点
    int top = 0;

    BinaryNode* p = t;//定义一个变量，便于操作
    while (p != NULL || top > 0) {
        while (p != NULL) {// 指针来访问节点，访问到最底层
            stack[top++] = p;// 将访问的节点放进栈
            p = p->left;//左
        }
 l
        if (top > 0) {
            p = stack[--top];// 从栈里弹出的数据，就是要处理的数据
            printf("%d ", p->data);
            p = p->right;// 右
        }
    }
}

// 非递归实现的后序遍历
void postOrderTraversal(BinaryTree t) {
    if (t == NULL) {
        return;
    }

    BinaryNode* stack[MAX_SIZE];  // 使用栈来保存节点
    int top = 0;
    BinaryNode* lastVisited = NULL;

    BinaryNode* p = t;
    while (p != NULL || top > 0) {
        while (p != NULL) {
            stack[top++] = p;
            p = p->left;
        }

        BinaryNode* node = stack[top - 1];
        // 当右子树为空或如果当前节点的右子树为空，或者右子树已经被访问过，就可以访问当前节点了。否则，将右子树入栈。
        if (node->right == NULL || node->right == lastVisited) {
            printf("%d ", node->data);
            top--;
            lastVisited = node;
        }
        else {
            p = node->right;
        }
    }
}
int main() {
    BinaryTree t;
    init(&t);

    printf("请输入先序遍历序列，-1表示该位置为NULL: ");
    build(&t);

    printf("递  归实现前序遍历结果: ");
    preRecursionTraversal(t);
    printf("\n");
    printf("非递归实现前序遍历结果: ");
    preOrderTraversal(t);
    printf("\n");
    printf("递  归实现中序遍历结果: ");
    midRecursionTraversal(t);
    printf("\n");
    printf("非递归实现中序遍历结果: ");
    midOrderTraversal(t);
    printf("\n");
    printf("递  归实现后序遍历结果: ");
    postRecursionTraversal(t);
    printf("\n");
    printf("非递归实现后序遍历结果: ");
    postOrderTraversal(t);
    printf("\n");

    return 0;
}
```

## 第十天

### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

```
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
```

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int arr[26]={0};
        for(int i=0;i<s.size();i++){
            arr[s[i]-'a']++;
        }
        for(int i=0;i<t.size();i++){
            arr[t[i]-'a']--;
        }
        for(int i=0;i<26;i++){
            if(arr[i]!=0)return false;
        }
        return true;
    }
};
```

```
需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，
所以字符a映射为下标0，相应的字符z映射为下标25。
再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，
并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。
那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，
对t中出现的字符映射哈希表索引上的数值再做-1的操作。
那么最后检查一下，arr数组如果有的元素不为零0
，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。
最后如果arr数组所有元素都为零0，说明字符串s和t是字母异位词，return true。
```

### [1002. 查找共用字符](https://leetcode.cn/problems/find-common-characters/)

```
给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。
```

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& words) {
        vector<string> result;
        if(words.size()==0)return result;
        int hash[26] = {0}; // 用来统计所有字符串里字符出现的最小频率
		for (int i = 0; i < A[0].size(); i++) { // 用第一个字符串给hash初始化
    		hash[A[0][i] - 'a']++;
			}
        
        int hashOtherStr[26] = {0}; // 统计除第一个字符串外字符的出现频率
		for (int i = 1; i < A.size(); i++) {
    	memset(hashOtherStr, 0, 26 * sizeof(int));//初始化hashOtherStr，为其每个值赋值为1
    	for (int j = 0; j < A[i].size(); j++) {
        hashOtherStr[A[i][j] - 'a']++;
    		}
    	// 这是关键所在
   		 for (int k = 0; k < 26; k++) { // 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数
       		 hash[k] = min(hash[k], hashOtherStr[k]);
        		}
			}
        for (int i = 0; i < 26; i++) {
            while (hash[i] != 0) { // 注意这里是while，多个重复的字符
                string s(1, i + 'a'); // char -> string
                result.push_back(s);
                hash[i]--;
            }
        }
        return result;
    }
    
};
```

```
整体思路就是统计出搜索字符串里26个字符的出现的频率，然后取每个字符频率最小值，最后转成输出格式就可以了。
```

```python
class Solution:
    def commonChars(self, words: List[str]) -> List[str]:
        tmp = collections.Counter(words[0])
        l = []
        for i in range(1,len(words)):
            # 使用 & 取交集
            tmp = tmp & collections.Counter(words[i])

        # 剩下的就是每个单词都出现的字符（键），个数（值）
        for j in tmp:
            v = tmp[j]
            while(v):
                l.append(j)
                v -= 1
        return l
```



## 第十一天

### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

```
给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。
```

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result;
        int hash[1001]={0};
        for(int num : nums1){
            hash[num]=1;
        }
        for(int num:nums2){
            if(hash[num]==1){
                result.insert(num);
            }
        }
        return vector<int>(result.begin(),result.end());
    }
};
```

```
把nums1的结果放在hash中，再判断nums2中出现hash中的数的话，用result记录
```

### [202. 快乐数](https://leetcode.cn/problems/happy-number/)

```
编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 
```

```c++
class Solution {
public:
int getSum(n){//求一个数的各数平方和
            int sum=0;
            while(n){
                sum=(n%10)*(n%10);
                n/=10;
            }
            return sum;
        }
    bool isHappy(int n) {
        unordered_set<int> set;
        while(1){
            int sum = getSum(n);
            if(sum==1)return true;
            //如果这个sum曾经出现过
            //说明已经陷入了无限循环了，立刻return false
            if(set.find(sum)!=set.end()){
                return false;
            }else{
                set.insert(sum);
            }
            n=sum;
        }
        
    }
};
```

````
使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。
````

## 第十二天

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。
```

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map <int,int> map;
        for(int i = 0; i < nums.size(); i++) {
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - nums[i]); 
            if(iter != map.end()) {
                return {iter->second, i};
            }
            // 如果没找到匹配对，就把访问过的元素和下标加入到map中
            map.insert(pair<int, int>(nums[i], i)); 
        }
        return {};
    }
};
```

```
map目的用来存放我们访问过的元素，因为遍历数组的时候，
需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）
接下来是map中key和value分别表示什么。
这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。
那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。
所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。
在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，
如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。
```

## 第十三天

```
非递归的统一迭代遍历和递归遍历
```

```C
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
// 二叉树链式存储结构体
typedef struct Node {
	int data;
	struct Node* left;
	struct Node* right;
} BinaryNode, * BinaryTree;

// 初始化二叉树
void init(BinaryTree* t) {
	*t = NULL;
}

// 创建新节点
BinaryNode* createNode(int x) {
	BinaryNode* node = (BinaryNode*)malloc(sizeof(BinaryNode));
	node->data = x;
	node->left = node->right = NULL;
	return node;
}

// 通过先序遍历序列构建二叉树
void build(BinaryTree* t) {
	int x;
	scanf_s("%d", &x);
	if (x == -1) {  // 当前节点为NULL
		*t = NULL;
	}
	else {  // 当前节点不为NULL
		BinaryNode* node = createNode(x);
		*t = node;
		build(&(node->left));  // 递归构建左子树
		build(&(node->right));  // 递归构建右子树
	}
}

// 递归实现的前序遍历
void preRecursionTraversal(BinaryTree t) {
	if (t != NULL) {
		printf("%d ", t->data);
		preRecursionTraversal(t->left);
		preRecursionTraversal(t->right);
	}
}
// 递归实现的中序遍历
void midRecursionTraversal(BinaryTree t) {
	if (t != NULL) {
		midRecursionTraversal(t->left);
		printf("%d ", t->data);
		midRecursionTraversal(t->right);
	}
}
// 递归实现的后序遍历
void postRecursionTraversal(BinaryTree t) {
	if (t != NULL) {
		postRecursionTraversal(t->left);
		postRecursionTraversal(t->right);
		printf("%d ", t->data);
	}
}


// 非递归实现的前序遍历
void preOrderTraversal(BinaryTree* t) {
	// 检查根节点是否为空。
	if (t == NULL) {
		printf("空树");
		return;
	}

	//定义栈顶指针和数组
	BinaryNode* stack[MAX_SIZE];
	int top = 0;

	// 将根节点入栈。
	stack[top++] = t;

	// 当栈非空时，循环执行以下操作：
	while (top) {
		// 取出栈顶元素。
		BinaryNode* node = stack[--top];

		// 如果元素不为 NULL，执行如下操作：
		if (node != NULL) {
			// 如果存在右子树，将右子树入栈
			if (node->right) stack[top++] = node->right;
			// 如果存在左子树，将左子树入栈
			if (node->left) stack[top++] = node->left;

			// 将当前节点入栈
			stack[top++] = node;
			// 将 NULL 入栈，表示该节点已经遍历过
			stack[top++] = NULL;
		}
		// 如果元素为 NULL，执行如下操作：
		else {
			// 取出上一个节点
			node = stack[--top];
			// 打印节点的值
			printf("%d ", node->data);
		}
	}
}
// 非递归实现的中序遍历
void midOrderTraversal(BinaryTree* t) {
	if (t == NULL) {
		printf("空树");
		return;
	}

	BinaryNode* stack[MAX_SIZE];
	int top = 0;

	// 将根节点入栈。
	stack[top++] = t;

	while (top) {
		// 取出栈顶元素。
		BinaryNode* node = stack[--top];

		if (node != NULL) {
			if (node->right) stack[top++] = node->right;
			stack[top++] = node;
			// 将 NULL 入栈，表示该节点已经遍历过
			stack[top++] = NULL;
			if (node->left) stack[top++] = node->left;
		}
		// 如果元素为 NULL，执行如下操作：
		else {
			node = stack[--top];
			// 打印节点的值
			printf("%d ", node->data);
		}
	}
}

// 非递归实现的后序遍历
void postOrderTraversal(BinaryTree t) {
	if (t == NULL) {
		printf("空树");
		return;
	}
	BinaryNode* stack[MAX_SIZE];
	int top = 0;

	stack[top++] = t;

	while (top)
	{
		BinaryNode* node = stack[--top];
		if (node != NULL) {
			stack[top++] = node;
			stack[top++] = NULL;

			if (node->right)stack[top++] = node->right;

			if (node->left)stack[top++] = node->left;
		}
		else
		{
			node = stack[--top];
			printf("%d ", node->data);
		}
	}
}
int main() {
	BinaryTree t;
	init(&t);

	printf("请输入先序遍历序列，-1表示该位置为NULL: ");
	build(&t);

	printf("递  归实现前序遍历结果: ");
	preRecursionTraversal(t);
	printf("\n");
	printf("非递归实现前序遍历结果: ");
	preOrderTraversal(t);
	printf("\n");
	printf("递  归实现中序遍历结果: ");
	midRecursionTraversal(t);
	printf("\n");
	printf("非递归实现中序遍历结果: ");
	midOrderTraversal(t);
	printf("\n");
	printf("递  归实现后序遍历结果: ");
	postRecursionTraversal(t);
	printf("\n");
	printf("非递归实现后序遍历结果: ");
	postOrderTraversal(t);
	printf("\n");

	return 0;
}
```

## 第十四天

```
层次遍历二叉树；
按满二叉树方式建立二叉树；
按先序遍历方式建立二叉树；
求二叉树的叶子结点数；
求二叉树的深度
```

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
// 二叉树链式存储结构体
typedef struct Node {
	int data;
	struct Node* left;
	struct Node* right;
} BinaryNode, * BinaryTree;

// 初始化二叉树
void init(BinaryTree* t) {
	*t = NULL;
}

// 创建新节点
BinaryNode* createNode(int x) {
	BinaryNode* node = (BinaryNode*)malloc(sizeof(BinaryNode));
	node->data = x;
	node->left = node->right = NULL;
	return node;
}

// 按先序遍历序列构建二叉树
void build(BinaryTree* t) {
	int x;
	scanf_s("%d", &x);
	if (x == -1) {  // 当前节点为NULL
		*t = NULL;
	}
	else {  // 当前节点不为NULL
		BinaryNode* node = createNode(x);
		*t = node;
		build(&(node->left));  // 递归构建左子树
		build(&(node->right));  // 递归构建右子树
	}
}

// 按满二叉树方式建立二叉树
BinaryNode* build1() {
	BinaryNode * p, * t=NULL, * s[MAX_SIZE];
	char x; int  i, j;
	while (1)
	{
		scanf_s("%d", &i);
		if (i == 0)break;
		else
		{
			x = getchar();
			p = createNode(x);
			s[i] = p;
			if (i == 1) t = p;
			else
			{
				j = i / 2;
				if (i % 2 == 0) s[j]->left = p;
				else s[j]->right = p;
			}
		}
	}
	return t;
}

// 二叉树的层序遍历
void sequenceTraversal(BinaryTree t,int i) {
	if (t == NULL) {
		printf("空树");
		return;
	}
	BinaryNode* queue[MAX_SIZE], * p = t;
	int front = 0, rear = 0;
	if (p != NULL) {
		queue[rear++] = p;
		while (front < rear) {
			p = queue[front++];
			if(i==1)printf("%d ", p->data);
			else printf("%c ", p->data);

			if (p->left != NULL)queue[rear++] = p->left;
			if (p->right != NULL)queue[rear++] = p->right;

		}
	}
}
//求二叉树的最大深度
int maxDepth(BinaryTree t) {
	int depth = 0;
	if (t == NULL) {
		return depth;
	}
	BinaryNode* queue[MAX_SIZE], * p = t;
	int front = 0, rear = 0, level;
	if (t != NULL) {
		queue[rear++] = p;
		level = rear;
		while (front < rear) {
			p = queue[front++];
			if (p->left != NULL)queue[rear++] = p->left;
			if (p->right != NULL)queue[rear++] = p->right;
			if (front == level) {
				depth++;
				level = rear;
			}
		}
	}
	return depth;
}
//求二叉树的叶子节点数
int BTreeNum(BinaryTree t) {
	int num = 0;
	if (t == NULL) {
		return num;
	}
	BinaryNode* queue[MAX_SIZE], * p = t;
	int front = 0, rear = 0;
	if (p != NULL) {
		queue[rear++] = p;
		while (front < rear) {
			p = queue[front++];
			if (p->left == NULL && p->right == NULL)num++;
			if (p->left != NULL)queue[rear++] = p->left;
			if (p->right != NULL)queue[rear++] = p->right;

		}
	}
	return num;
}

//1 2 3 -1 -1 4 -1 -1 5 6 -1 -1 -1
int main() {
	BinaryTree t;
	int i = 0;
	init(&t);
	printf("选择创建二叉树方式（1为先序，2为层序）：");
	scanf_s("%d", &i);
	switch (i)
	{
	case 1:
		printf("请输入先序遍历序列，-1表示该位置为NULL: ");
		build(&t);
		break;
	case 2:
		printf("请输入层序遍历序列，0表示结束示例: \n");
		printf("序号 值");
		t = build1();
		break;

	default:
		break;
	}
	printf("层序遍历结果: ");
	sequenceTraversal(t,i);
	printf("\n");
	printf("该树一共有%d个叶子节点.", BTreeNum(t));
	printf("\n");
	printf("该树的最大深度为%d.", maxDepth(t));
	return 0;
}
```

## 第十五天

### [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

```
给你四个整数数组 nums1、nums2、nums3 和 nums4 ，
数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
```

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int>umap;//key:a+b的值 value：a+b值出现的次数
        for(int a:nums1){//遍历num1和num2数组，统计出两个数组元素相加和值出现的次数
            for(int b:nums2){
                umap[a+b]++;//存储在unordered_map中。使对应值（a+b）的次数++
            }
        }
        int count=0;//用于统计四数相加为0的次数
        for(int c:nums3){
            for(int d:nums4){
                if(umap.find(0-(c+d))!=umap.end()){//说明有元素满足0+（a+b）
                count += umap[0-(c+d)];//则将对应出现的次数（value：a+b+c+d=0值出现的次数）加等到计数器上
                }
            }
        }
        return count;
    }
};
```

```
1.首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
2.遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3.定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4.在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的5.value也就是出现次数统计出来。
6.最后返回统计值 count 就可以了
```

### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

```
给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次

提示：ransomNote 和 magazine 由小写英文字母组成
```

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int rec[26]={0};
        if(magazine.size()<ransomNote.size()){//如果magazine中的字符数少与ransomNote，则不可能写出ransomNote
            return false;//所以返回false
        }
        for(int i=0;i<magazine.size();i++){
            rec[magazine[i]-'a']++;//把magazine数组中所有字符出现的次数按对应字母顺序存储到rec中
        }
        for(int j=0;j<ransomNote.size();j++){
            rec[ransomNote[j]-'a']--;//再将ransomNote中有的字符，在rec中删除

            if(rec[ransomNote[j]-'a']<0){//在删除的过程中，如果小于零说明ransomNote里出现的字符，magazine没有
                return false;
            }
        }
        return true;
    }
};
```

## 第十六天

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

```
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，
同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
```

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());//从小到大进行排序

        for(int i=0;i<nums.size();i++){
            if(nums[i]>0) return result;//说明所有都大于0。其和不可能为0
            
            if(i>0&&nums[i]==nums[i-1]) continue;//去重,还有因为有i-1的操作，所以要加一个判断i>0的条件
            
            int left=i+1;
            int right =nums.size()-1;
            
            while(left<right){//不能写<= ,因为等于时就没有指向三个数了
                if(nums[i]+nums[right]+nums[left]>0) right--;
                else if(nums[i]+nums[right]+nums[left]<0) left++;
                
                else{ result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重,因为要防止{0，0，0，0，0，0}例如这样的nums
                // 如果放在前面，将收集不到结果
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
};
```

```
首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。
依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。
接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。
如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。
```

## 第十七天

### [18. 四数之和](https://leetcode.cn/problems/4sum/)

```
给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

0 <= a, b, c, d < n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。
```

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());//从小到大进行排序

        for(int i=0;i<nums.size();i++){
            if(nums[i]>target &&(nums[i]>=0)) break;//剪枝
            
            if(i>0&&nums[i]==nums[i-1]) continue;//去重,还有因为有i-1的操作，所以要加一个判断i>0的条件
            
            for(int k=i+1;k<nums.size();k++){
                if(nums[i]+nums[k]>target&&nums[i]+nums[k]>=0)break;//再次剪枝

                if(k>i+1&&nums[k]==nums[k-1])continue;// 再次去重

                int left=k+1;
                int right =nums.size()-1;
            
                while(left<right){//不能写<= ,因为等于时就没有指向四个数了
                    if((long)nums[i]+nums[right]+nums[left]+nums[k]>target) right--;
                    else if((long)nums[i]+nums[right]+nums[left]+nums[k]<target) left++;
                    
                    else{ result.push_back(vector<int>{nums[i], nums[left], nums[right],nums[k]});
                    // 去重逻辑应该放在找到一个四元组之后
                    // 如果放在前面，将收集不到结果
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }
            }
        }
        return result;
    }
};
```

```
和三数之和是相同的思路。但有很多不同的细节
```

### [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

```
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
```

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0;int right=s.size()-1;
        char temp;
        while(left<right){
            char temp=s[right];
            s[right]=s[left];
            s[left]=temp;
            left++;right--;
        }
    }
};
```

进行一波改造，速度提升

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for(int i=0,j=s.size()-1;i<s.size()/2;i++,j--){
            swap(s[i],s[j]);
        }
    }
};
```

```
思路很简单，就是使用双指针，从两端出发，以此交换
```

### [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

```
给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。
	如果剩余字符少于 k 个，则将剩余字符全部反转。
	如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
```

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        for(int i=0;i<s.size();i+=(2*k)){
            if(i+k<s.size()){//当前位置加上反转范围小于s.size()
            reverse(s.begin()+i,s.begin()+i+k);

            }else{//把剩下的全部反转
                reverse(s.begin()+i,s.end());
            }
        }
        return s;
    }
};
```

```
遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。
因为要找的也就是每2 * k 区间的起点
```

## 第十八天

### [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

```
请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
```

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int count =0; // 用于统计空格的数目
        int OldSize= s.size();//记录扩充字符串前的字符串大小
        for(int i=0;i<s.size();i++){//统计空格数
            if(s[i]==' ') count++;
        }
        s.resize(s.size()+count*2);//扩充字符串大小
        int NewSize= s.size();
        //利用双指针从后面进行循环
        for(int i= NewSize-1,j=OldSize-1;j<i;j--,i--){
            if(s[j]!=' ')s[i]=s[j];//在指针向后移动的过程中，如果前面的指针不等于空格则将前面的字符复制的后面来
            else{
                s[i]='0';
                s[i-1]='2';
                s[i-2]='%';
                i-=2;
            }
        }
        return s;
    }
};
```

```
首先扩充数组到每个空格替换成"%20"之后的大小。
然后从后向前替换空格，也就是双指针法，过程如下：
i指向新长度的末尾，j指向旧长度的末尾
```

### [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

```
给你一个字符串 s ，请你反转字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
```

```c++
class Solution {
public:
    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }
      void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
        int slow = 0;  
        for (int i = 0; i < s.size(); ++i) { //
            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                    s[slow++] = s[i++];
                }
            }
        }
        s.resize(slow); //slow的大小即为去除多余空格后的大小。
    }

    string reverseWords(string s) {
        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
        reverse(s, 0, s.size() - 1);
        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。
                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。
                start = i + 1; //更新下一个单词的开始下标start
            }
        }
        return s;
    }
};
```

```
定义一个 removeExtraSpaces 函数，该函数的作用是去除字符串中的多余空
格，并在相邻单词之间添加一个空格。具体实现方式为使用快慢指针遍历整个字符
串，快指针指向当前处理的字符，慢指针指向可以插入空格的位置，当遇到一个非
空格字符时，将其插入到慢指针所指向的位置，同时在相邻单词之间添加一个空
格。最后使用 resize 函数将字符串的长度改为去除多余空格后的长度。

定义一个 reverse 函数，该函数的作用是将一个字符串的指定区间翻转。具体实现方式为使用双指针，分别从区间的两端开始向中间遍历，交换两个指针所指向的字符。

调用 removeExtraSpaces 函数去除字符串中的多余空格。

调用 reverse 函数将整个字符串翻转。

使用双指针遍历整个字符串，当遇到一个空格或字符串结尾时，说明一个单词结束，调用 reverse 函数将该单词翻转，然后继续遍历下一个单词。

返回翻转后的字符串
```

## 第十九天

### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
```

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(),s.begin()+n);//反转前n个
        reverse(s.begin()+n,s.end());//反转剩下的
        reverse(s.begin(),s.end());//再反转所有
        return s;
    }
};
```

```
很容易理解

```

##  第二十天

### [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

```
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。
```

```c++
class Solution {
public:
    // 计算模式串的next数组
    void getNext(int* next, const string& s) {
        int i = 0, j = -1;
        int plen = s.size();
        next[0] = -1;
        while (i < plen - 1) {  // 注意循环条件是i<plen-1而不是i<plen
            if (j == -1 || s[i] == s[j]) {
                i++;
                j++;
                next[i] = j;
            } else {
                j = next[j];
            }
        }
    }

    // 在文本串中查找模式串的位置
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);  // 计算模式串的next数组
        int haylen = haystack.size();
        int needlen = needle.size();
        int i = 0, j = 0;
        while (i < haylen && j < needlen) {
            if (j == -1 || haystack[i] == needle[j]) {
                i++;
                j++;
            } else {
                j = next[j];  // 移动模式串，继续匹配
            }
        }
        if (j == needlen) {  // 匹配成功，返回模式串在文本串中第一次出现的位置
            return i - j;
        }
        return -1;  // 匹配失败
    }
};
```

```
经典的KMP算法
```

## 第二十一天

###  [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

```
给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成
```

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        return (s+s).find(s,1)!=s.size();
    }
};
```

```
留
空 

用
于
写
KMP
方
法
```

### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

```
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
```

```c++
class MyQueue {
public:
    stack<int> StIn;//输入栈
    stack<int> StOut;//输出栈
    MyQueue() {

    }
    
    void push(int x) {//入队
        StIn.push(x);//将元素加入输入栈
    }
    
    int pop() {//输出元素，并删除队中元素
        if(StOut.empty()){//判断输出栈是否为空
            while(!StIn.empty()){//如果为空，就将输入栈中的所有元素，输出到输出栈中
                StOut.push(StIn.top());//将顶部元素加入到输出栈中
                StIn.pop();//上一步只是取到top，没有删除，在这一步删除
            }
        }
         int a = StOut.top();
         StOut.pop();
        return a;//取出，删除，返回
    }
    
    int peek() {//实现取出元素，但不删除
        int a=this->pop();//将元素弹出来了
        StOut.push(a);//在加回去
        return a;

    }
    
    bool empty() {//判断队列是否为空
        return StIn.empty()&&StOut.empty();//两个栈都为空时，队列就为空了
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



