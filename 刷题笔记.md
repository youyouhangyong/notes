## ç¬¬ä¸€å¤©

### [704. äºŒåˆ†æŸ¥æ‰¾](https://leetcode.cn/problems/binary-search/)

```
ç»™å®šä¸€ä¸ªÂ nÂ ä¸ªå…ƒç´ æœ‰åºçš„ï¼ˆå‡åºï¼‰æ•´å‹æ•°ç»„Â nums å’Œä¸€ä¸ªç›®æ ‡å€¼Â target Â ï¼Œå†™ä¸€ä¸ªå‡½æ•°æœç´¢Â numsÂ ä¸­çš„ targetï¼Œå¦‚æœç›®æ ‡å€¼å­˜åœ¨è¿”å›ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1ã€‚
```

```c++
int search(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}

```

```
åœ¨æ­¤å®ç°ä¸­ï¼Œæˆ‘ä»¬å°†ä¸¤ä¸ªæŒ‡é’ˆ left å’Œ right åˆå§‹åŒ–ä¸º nums å‘é‡çš„å¼€å§‹å’Œç»“å°¾ï¼Œåˆ†åˆ«è¡¨ç¤ºå½“å‰è¦æŸ¥æ‰¾çš„å­æ•°ç»„çš„å·¦å³ç«¯ç‚¹ã€‚
ç„¶åï¼Œæˆ‘ä»¬é‡å¤è®¡ç®— left å’Œ right ä¹‹é—´çš„ä¸­ç‚¹ midï¼Œå¹¶å°† nums[mid] ä¸ target å…ƒç´ è¿›è¡Œæ¯”è¾ƒã€‚
å¦‚æœ nums[mid] ç­‰äº targetï¼Œåˆ™è¿”å›ç´¢å¼• midã€‚
å¦åˆ™ï¼Œå¦‚æœ nums[mid] å°äº targetï¼Œåˆ™å°† left = mid + 1ï¼Œä»¥åœ¨å­æ•°ç»„çš„å³åŠéƒ¨åˆ†ä¸­æŸ¥æ‰¾ targetã€‚
åŒæ ·ï¼Œå¦‚æœ nums[mid] å¤§äº targetï¼Œåˆ™å°† right = mid - 1ï¼Œä»¥åœ¨å­æ•°ç»„çš„å·¦åŠéƒ¨åˆ†ä¸­æŸ¥æ‰¾ targetã€‚
æˆ‘ä»¬ç»§ç»­è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°æˆ‘ä»¬æ‰¾åˆ° target å…ƒç´ æˆ– left è¶…è¿‡äº† rightï¼Œè¿™è¡¨æ˜ nums å‘é‡ä¸­ä¸å­˜åœ¨ target å…ƒç´ ã€‚
åœ¨åä¸€ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¿”å› -1ï¼Œä»¥è¡¨ç¤ºæœªæ‰¾åˆ° target å…ƒç´ ã€‚
```

### [27. ç§»é™¤å…ƒç´ ](https://leetcode.cn/problems/remove-element/)

```
ç»™ä½ ä¸€ä¸ªæ•°ç»„ numsÂ å’Œä¸€ä¸ªå€¼ valï¼Œä½ éœ€è¦ åŸåœ° ç§»é™¤æ‰€æœ‰æ•°å€¼ç­‰äºÂ valÂ çš„å…ƒç´ ï¼Œå¹¶è¿”å›ç§»é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚
ä¸è¦ä½¿ç”¨é¢å¤–çš„æ•°ç»„ç©ºé—´ï¼Œä½ å¿…é¡»ä»…ä½¿ç”¨ O(1) é¢å¤–ç©ºé—´å¹¶ åŸåœ° ä¿®æ”¹è¾“å…¥æ•°ç»„ã€‚
å…ƒç´ çš„é¡ºåºå¯ä»¥æ”¹å˜ã€‚ä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚
```

```c++
int removeElement(vector<int>& nums, int val) {
    int i = 0;
    for (int j = 0; j < nums.size(); j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
 }

```

```
ä½¿ç”¨åŒæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æ•°ç»„çš„å½“å‰å…ƒç´ ï¼Œå¦ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å½“å‰è¦åˆ é™¤çš„å…ƒç´ çš„ä½ç½®ã€‚
å¦‚æœå½“å‰å…ƒç´ ä¸ç­‰äºç»™å®šå€¼valï¼Œåˆ™å°†è¯¥å…ƒç´ å¤åˆ¶åˆ°ç¬¬äºŒä¸ªæŒ‡é’ˆæ‰€æŒ‡å‘çš„ä½ç½®ï¼Œå¹¶å°†ç¬¬äºŒä¸ªæŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä¸ªä½ç½®ã€‚
æœ€åè¿”å›ç¬¬äºŒä¸ªæŒ‡é’ˆæ‰€æŒ‡å‘çš„ä½ç½®ï¼Œå³ä¸ºåˆ é™¤ç»™å®šå€¼valåæ•°ç»„çš„æ–°é•¿åº¦ã€‚
```

### [977. æœ‰åºæ•°ç»„çš„å¹³æ–¹](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```
ç»™ä½ ä¸€ä¸ªæŒ‰ éé€’å‡é¡ºåº æ’åºçš„æ•´æ•°æ•°ç»„ numsï¼Œè¿”å› æ¯ä¸ªæ•°å­—çš„å¹³æ–¹ ç»„æˆçš„æ–°æ•°ç»„ï¼Œè¦æ±‚ä¹ŸæŒ‰ éé€’å‡é¡ºåº æ’åºã€‚
```

```c++
vector<int> sortedSquares(vector<int>& nums) {
        int n=nums.size();
        vector<int> result(n);//å¯ä»¥ä½¿ç”¨ vector ç±»å‹æ¥åŠ¨æ€åˆ†é…å†…å­˜
        int left = 0,right = n-1;
        int index = n-1;
        while(left<=right){
            if(nums[left]*nums[left]>nums[right]*nums[right]){
                result[index]=nums[left]*nums[left];//ç¬¬ä¸€æ¬¡å­˜å…¥resultçš„æœ€åä¸€ä¸ªä½ç½®
                left++;
            }else{
                result[index]=nums[right]*nums[right];
                right--;
            }
            index--;
        }
        return result;
    }
```

```
ä½¿ç”¨åŒæŒ‡é’ˆæ³•ï¼Œé¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥å°†åŸæ•°ç»„ä¸­çš„æ¯ä¸ªæ•°å¹³æ–¹ï¼Œç„¶åå†æŒ‰ç…§éé€’å‡é¡ºåºæ’åºã€‚
ç”±äºæ•°ç»„å·²ç»æŒ‰ç…§éé€’å‡é¡ºåºæ’å¥½åºäº†ï¼Œ
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘æ•°ç»„çš„æœ€å·¦ç«¯å’Œæœ€å³ç«¯ã€‚
æ¯”è¾ƒä¸¤ä¸ªæŒ‡é’ˆæ‰€æŒ‡å‘çš„æ•°çš„å¹³æ–¹å€¼ï¼Œå°†è¾ƒå¤§çš„é‚£ä¸ªæ”¾å…¥æ–°æ•°ç»„çš„æœ«å°¾ã€‚
ç§»åŠ¨æŒ‡é’ˆæ—¶ï¼Œéœ€è¦åˆ¤æ–­æŒ‡é’ˆæ‰€æŒ‡å‘çš„æ•°æ˜¯å¦å·²ç»è¢«åŠ å…¥äº†æ–°æ•°ç»„ä¸­ï¼Œå¦‚æœå·²ç»è¢«åŠ å…¥äº†ï¼Œåˆ™éœ€è¦è·³è¿‡ã€‚
```

## ç¬¬äºŒå¤©


### [209. é•¿åº¦æœ€å°çš„å­æ•°ç»„](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```
ç»™å®šä¸€ä¸ªå«æœ‰Â nÂ ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° target ã€‚

æ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶å’Œ â‰¥ target çš„é•¿åº¦æœ€å°çš„ è¿ç»­å­æ•°ç»„Â [numsl, numsl+1, ..., numsr-1, numsr] ï¼Œå¹¶è¿”å›å…¶é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› 0 ã€‚

```

```c++
int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // æ»‘åŠ¨çª—å£æ•°å€¼ä¹‹å’Œ
        int i = 0; // æ»‘åŠ¨çª—å£èµ·å§‹ä½ç½®
        int subLength = 0; // æ»‘åŠ¨çª—å£çš„é•¿åº¦
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // æ³¨æ„è¿™é‡Œä½¿ç”¨whileï¼Œæ¯æ¬¡æ›´æ–° iï¼ˆèµ·å§‹ä½ç½®ï¼‰ï¼Œå¹¶ä¸æ–­æ¯”è¾ƒå­åºåˆ—æ˜¯å¦ç¬¦åˆæ¡ä»¶
            while (sum >= s) {
                subLength = (j - i + 1); // å–å­åºåˆ—çš„é•¿åº¦
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // è¿™é‡Œä½“ç°å‡ºæ»‘åŠ¨çª—å£çš„ç²¾é«“ä¹‹å¤„ï¼Œä¸æ–­å˜æ›´iï¼ˆå­åºåˆ—çš„èµ·å§‹ä½ç½®ï¼‰
            }
        }
        // å¦‚æœresultæ²¡æœ‰è¢«èµ‹å€¼çš„è¯ï¼Œå°±è¿”å›0ï¼Œè¯´æ˜æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„å­åºåˆ—
        return result == INT32_MAX ? 0 : result;
    }
```

```
è¯¥å‡½æ•°é‡‡ç”¨æ»‘åŠ¨çª—å£ç®—æ³•ï¼Œä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆ i å’Œ j è¡¨ç¤ºæ»‘åŠ¨çª—å£çš„å·¦å³è¾¹ç•Œï¼Œ
ç”¨å˜é‡ sum è¡¨ç¤ºæ»‘åŠ¨çª—å£å†…çš„å…ƒç´ ä¹‹å’Œï¼Œç”¨å˜é‡ subLength è¡¨ç¤ºå½“å‰ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„çš„é•¿åº¦ï¼Œç”¨å˜é‡ result è¡¨ç¤ºæœ€ç»ˆçš„ç»“æœã€‚
éå†æ•°ç»„ 'nums'ï¼Œä¸æ–­å°†å…ƒç´ æ·»åŠ åˆ°æ»‘åŠ¨çª—å£ä¸­ï¼Œå½“æ»‘åŠ¨çª—å£å†…å…ƒç´ ä¹‹å’Œ sum å¤§äºæˆ–ç­‰äºç»™å®šæ•´æ•° 's' æ—¶ï¼Œ
é€šè¿‡ä¸æ–­ç§»åŠ¨æŒ‡é’ˆ i æ¥ç¼©å°æ»‘åŠ¨çª—å£çš„å¤§å°ï¼ŒåŒæ—¶æ›´æ–°å˜é‡ subLength å’Œ resultï¼Œ
æœ€ç»ˆè¿”å› result çš„å€¼ã€‚ å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œåˆ™è¿”å› 0ã€‚
```

### [35. æœç´¢æ’å…¥ä½ç½®](https://leetcode.cn/problems/search-insert-position/)

```
ç»™å®šä¸€ä¸ªæ’åºæ•°ç»„å’Œä¸€ä¸ªç›®æ ‡å€¼ï¼Œåœ¨æ•°ç»„ä¸­æ‰¾åˆ°ç›®æ ‡å€¼ï¼Œå¹¶è¿”å›å…¶ç´¢å¼•ã€‚å¦‚æœç›®æ ‡å€¼ä¸å­˜åœ¨äºæ•°ç»„ä¸­ï¼Œè¿”å›å®ƒå°†ä¼šè¢«æŒ‰é¡ºåºæ’å…¥çš„ä½ç½®ã€‚

è¯·å¿…é¡»ä½¿ç”¨æ—¶é—´å¤æ‚åº¦ä¸º O(log n) çš„ç®—æ³•ã€‚
```

```c++
int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right){
            int mid = (left + right) / 2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid]<target){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return left;
    }
```

```
é¦–å…ˆï¼Œåˆ¤æ–­ç›®æ ‡å€¼æ˜¯å¦åœ¨æ•°ç»„ä¸­å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨ï¼Œè¿”å›å®ƒçš„ç´¢å¼•ã€‚
å¦‚æœç›®æ ‡å€¼ä¸åœ¨æ•°ç»„ä¸­ï¼Œå¯ä»¥é€šè¿‡äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°å®ƒåº”è¯¥è¢«æ’å…¥çš„ä½ç½®ã€‚
å…·ä½“æ¥è¯´ï¼Œå¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆ left å’Œ right åˆ†åˆ«æŒ‡å‘æ•°ç»„çš„èµ·å§‹å’Œç»“æŸä½ç½®ã€‚
ç„¶åï¼Œè®¡ç®—å®ƒä»¬çš„ä¸­é—´ä½ç½® midï¼Œå¹¶å°†ç›®æ ‡å€¼ä¸ nums[mid] è¿›è¡Œæ¯”è¾ƒã€‚
å¦‚æœç›®æ ‡å€¼å°äº nums[mid]ï¼Œåˆ™å°† right æŒ‡é’ˆç§»åŠ¨åˆ° mid - 1 çš„ä½ç½®ï¼›
å¦‚æœç›®æ ‡å€¼å¤§äº nums[mid]ï¼Œåˆ™å°† left æŒ‡é’ˆç§»åŠ¨åˆ° mid + 1 çš„ä½ç½®ã€‚é‡å¤ä»¥ä¸Šæ­¥éª¤ï¼Œç›´åˆ°æ‰¾åˆ°ç›®æ ‡å€¼æˆ–è€… left > rightã€‚
å¦‚æœæ‰¾ä¸åˆ°ç›®æ ‡å€¼ï¼Œæœ€å left çš„ä½ç½®å°±æ˜¯ç›®æ ‡å€¼åº”è¯¥è¢«æ’å…¥çš„ä½ç½®ã€‚
```

### [34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftBor =getLeft(nums ,target);
        int rightBor =getRight(nums,target);
        if(leftBor== -2||rightBor== -2)return {-1,-1};
        if(rightBor-leftBor>1)return{leftBor+1,rightBor-1};
        return {-1,-1};
    }
    private:
        int getRight(vector<int>&nums,int target){
            int left =0 ;
            int right =nums.size()-1;
            int rightBor=-2;
            while(left<=right){
                int mid = left+((right-left)/2);
                if(nums[mid]>target){
                    right = mid-1;
                }else{
                    left=mid+1;
                    rightBor =left;
                }
            }
            return rightBor;
        }
        int getLeft(vector<int>&nums,int target){
            int left =0 ;
            int right =nums.size()-1;
            int leftBor=-2;
            while(left<=right){
                int mid = left+((right-left)/2);
                if(nums[mid]>=target){
                    right=mid-1;
                    leftBor = right;
                }else{
                    left=mid+1;
                }
            }
            return leftBor;
        }
};
```

```
å¯ä»¥ç¼–å†™ä¸¤ä¸ªå‡½æ•° getRight() å’Œ getLeft()ï¼Œå®ƒä»¬åˆ†åˆ«ç”¨äºæŸ¥æ‰¾ç›®æ ‡å€¼åœ¨æ•°ç»„ä¸­ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ã€‚
åœ¨è¿™ä¸¤ä¸ªå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ¥æœç´¢ç›®æ ‡å€¼ï¼Œ
å½“æ‰¾åˆ°ç›®æ ‡å€¼æ—¶ï¼Œæˆ‘ä»¬ä¼šè®°å½•å®ƒçš„ä½ç½®ï¼Œå¹¶ç»§ç»­åœ¨å·¦åŠéƒ¨åˆ†æˆ–å³åŠéƒ¨åˆ†ä¸­æœç´¢ï¼Œ
ç›´åˆ°æ‰¾åˆ°æœ€åä¸€ä¸ªç›®æ ‡å€¼å‡ºç°çš„ä½ç½®ã€‚å¦‚æœç›®æ ‡å€¼ä¸å­˜åœ¨äºæ•°ç»„ä¸­ï¼Œåˆ™è¿”å› [-1, -1]ã€‚
```

ä»£ç å¯ä»¥è¿›è¡Œç®€åŒ–

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size();
        int left = findBound(nums, n, target, true);
        int right = findBound(nums, n, target, false);
        if (left <= right) {
            return {left, right};
        } else {
            return {-1, -1};
        }
    }

private:
    int findBound(vector<int>& nums, int n, int target, bool isLeft) {
        int left = 0, right = n - 1;
        int res = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                res = mid;
                if (isLeft) right = mid - 1;
                else left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return res;
    }
};

```

```
å¯ä»¥å°† findFirst() å’Œ findLast() åˆå¹¶ä¸ºä¸€ä¸ªå‡½æ•°ï¼Œ
å¹¶ä½¿ç”¨ä¸€ä¸ªé¢å¤–çš„å‚æ•° isLeft æ¥æŒ‡ç¤ºæˆ‘ä»¬æ˜¯åœ¨æŸ¥æ‰¾ç›®æ ‡å€¼çš„ç¬¬ä¸€æ¬¡å‡ºç°ä½ç½®è¿˜æ˜¯æœ€åä¸€æ¬¡å‡ºç°ä½ç½®ã€‚
åœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ç®—æ³•æ¥æœç´¢ç›®æ ‡å€¼ï¼Œå¹¶åœ¨æ‰¾åˆ°ç›®æ ‡å€¼æ—¶æ›´æ–°å·¦å³æŒ‡é’ˆã€‚
å½“æ‰¾åˆ°ç›®æ ‡å€¼æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®å‚æ•° isLeft æ¥æ›´æ–°å·¦å³æŒ‡é’ˆï¼Œä»¥ä¾¿åœ¨æ­£ç¡®çš„åŠè¾¹ç»§ç»­æŸ¥æ‰¾ã€‚
åœ¨ searchRange() å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬å…ˆè°ƒç”¨ findBound() æ‰¾åˆ°ç›®æ ‡å€¼çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œç„¶åå†æ¬¡è°ƒç”¨ findBound() æ‰¾åˆ°ç›®æ ‡å€¼çš„æœ€åä¸€ä¸ªä½ç½®ã€‚
å¦‚æœç¬¬ä¸€ä¸ªä½ç½®å°äºç­‰äºæœ€åä¸€ä¸ªä½ç½®ï¼Œåˆ™è¿”å›ç»“æœåŒºé—´ [left, right]ï¼›å¦åˆ™ï¼Œè¿”å› [-1, -1]ï¼Œè¡¨ç¤ºæœªæ‰¾åˆ°ç›®æ ‡å€¼ã€‚
```

### [69. x çš„å¹³æ–¹æ ¹](https://leetcode.cn/problems/sqrtx/)

æ€è·¯æ¥è‡ª[BV1Qe411P7rs](https://www.bilibili.com/video/BV1Qe411P7rs/?spm_id_from=333.337.search-card.all.click&vd_source=a7dd7e2ac79efdb10cc027f8d64f3d6d)

> **expå‡½æ•°+ç²¾åº¦ä¿®æ­£**
>
> ```c++
> class Solution {
> public:
>     int mySqrt(int x) {
>         return (int)( exp(log(x)/2)+1e-8);
>     }
> };
> ```
>
> ä¼šå¯¼è‡´ä¸åŒå¹³å°ç²¾åº¦ä¸ä¸€è‡´

>**æš´å‡»æšä¸¾**
>
>```c++
>class Solution {
>public:
>    int mySqrt(int x) {
>        for(int i=0;;i++){
>            if(i*i>x){
>                return i-1;
>            }
>        }
>    }
>};
>```
>
>æ—¶é—´å¤æ‚åº¦é«˜ï¼Œå¹¶ä¸”ä¼šå‡ºç°æº¢å‡º

> **ç‰›é¡¿è¿­ä»£**
>
> ```c++
> class Solution {
> public:
>     int mySqrt(int n) {
>         double x0,x1;
>         x1=12;
>         do{
>             x0=x1;
>             double v= f(x0,n);
>            x1=-v/(x0*2)+x0;
>         }while(fabs(x0-x1)>1e-8);
>         int ans =(int)(x0+1e-8);
>         if(ans*ans>n) --ans;
>         return ans;
>     }
>     private:
>     double f(double x,int n){
>         return x*x-n;
>     }
> };
> ```

>**äºŒè¿›åˆ¶æšä¸¾**
>
>```c++
>class Solution {
>public:
>    int mySqrt(int x) {
>        if (x <= 1) return x;
>        int left = 0, right = x / 2 + 1;
>        while (left < right) {
>            int mid = left + (right - left + 1) / 2;
>            if ((long long)mid * mid <= x) left = mid;
>            else right = mid - 1;
>        }
>        return left;
>    }
>}
>```
>
>```
>åœ¨å®ç°ä¸­ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†ç±»ä¼¼äºäºŒåˆ†æŸ¥æ‰¾çš„æ–¹å¼ï¼Œå°†å·¦å³è¾¹ç•Œä¸æ–­ç¼©å°ï¼Œç›´åˆ°å·¦å³è¾¹ç•Œé‡åˆæˆ–ç›¸é‚»ã€‚åœ¨æ¯æ¬¡æŸ¥æ‰¾æ—¶ï¼Œæˆ‘ä»¬å°†ä¸­é—´å€¼ mid çš„å¹³æ–¹ä¸ x è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åæ ¹æ®æ¯”è¾ƒç»“æœæ›´æ–°å·¦å³è¾¹ç•Œã€‚ç”±äºæˆ‘ä»¬è¦æ±‚çš„æ˜¯æ•´æ•°å¹³æ–¹æ ¹ï¼Œå› æ­¤ä¸­é—´å€¼ mid åº”è¯¥å–å³ä¸­ä½æ•°ï¼Œå³ (left + right + 1) / 2ã€‚
>éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äºæˆ‘ä»¬åœ¨æ¯”è¾ƒ mid çš„å¹³æ–¹ä¸ x çš„å¤§å°æ—¶å¯èƒ½ä¼šæº¢å‡ºï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å°† mid å’Œ x éƒ½è½¬æ¢ä¸ºé•¿æ•´å‹è¿›è¡Œè®¡ç®—ã€‚æ­¤å¤–ï¼Œåœ¨åˆ¤æ–­è¾¹ç•Œæ¡ä»¶æ—¶ï¼Œéœ€è¦ç‰¹åˆ¤ x=0 å’Œ x=1 çš„æƒ…å†µã€‚
>```

ä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒäºŒè¿›åˆ¶è¿­ä»£æ³•æ±‚æ•´æ•°å¹³æ–¹æ ¹çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log \log n)$ï¼Œè€Œç‰›é¡¿è¿­ä»£æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ã€‚å› æ­¤ï¼Œå½“ $n$ çš„ä½æ•°è¾ƒå¤§æ—¶ï¼Œç‰›é¡¿è¿­ä»£æ³•çš„é€Ÿåº¦ä¼šæ›´å¿«ã€‚

ä¸è¿‡éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç‰›é¡¿è¿­ä»£æ³•çš„å®ç°éœ€è¦è€ƒè™‘åˆ°æ•°å€¼è¯¯å·®çš„é—®é¢˜ï¼Œå› æ­¤åœ¨å…·ä½“å®ç°æ—¶éœ€è¦åšå‡ºä¸€äº›é¢å¤–çš„å¤„ç†ï¼Œä¾‹å¦‚ä½¿ç”¨ long long ç±»å‹æ¥å­˜å‚¨å˜é‡ï¼Œä»¥é¿å…æ•´æ•°æº¢å‡º

## ç¬¬ä¸‰å¤©

### [367. æœ‰æ•ˆçš„å®Œå…¨å¹³æ–¹æ•°](https://leetcode.cn/problems/valid-perfect-square/)

```
ç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° num ã€‚å¦‚æœ num æ˜¯ä¸€ä¸ªå®Œå…¨å¹³æ–¹æ•°ï¼Œåˆ™è¿”å› true ï¼Œå¦åˆ™è¿”å› false ã€‚

å®Œå…¨å¹³æ–¹æ•° æ˜¯ä¸€ä¸ªå¯ä»¥å†™æˆæŸä¸ªæ•´æ•°çš„å¹³æ–¹çš„æ•´æ•°ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒå¯ä»¥å†™æˆæŸä¸ªæ•´æ•°å’Œè‡ªèº«çš„ä¹˜ç§¯ã€‚

ä¸èƒ½ä½¿ç”¨ä»»ä½•å†…ç½®çš„åº“å‡½æ•°ï¼Œå¦‚Â  sqrt ã€‚
```

```c++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int i = 1;
        while(num>0){
            num -= i;
            i += 2;
        }
        return num == 0;
    }
};
```

```
ä½¿ç”¨äº†ä¸€ä¸ªé€’å¢çš„åºåˆ—æ¥ä¸æ–­å‡å»è¾“å…¥çš„æ•°å­—numï¼Œå¦‚æœæœ€ç»ˆnumç­‰äº0ï¼Œè¯´æ˜è¾“å…¥çš„æ•°å­—æ˜¯å®Œå…¨å¹³æ–¹æ•°ã€‚
```

### [904. æ°´æœæˆç¯®](https://leetcode.cn/problems/fruit-into-baskets/)

```
ä½ æ­£åœ¨æ¢è®¿ä¸€å®¶å†œåœºï¼Œå†œåœºä»å·¦åˆ°å³ç§æ¤äº†ä¸€æ’æœæ ‘ã€‚è¿™äº›æ ‘ç”¨ä¸€ä¸ªæ•´æ•°æ•°ç»„ fruits è¡¨ç¤ºï¼Œå…¶ä¸­ fruits[i] æ˜¯ç¬¬ i æ£µæ ‘ä¸Šçš„æ°´æœ ç§ç±» ã€‚

ä½ æƒ³è¦å°½å¯èƒ½å¤šåœ°æ”¶é›†æ°´æœã€‚ç„¶è€Œï¼Œå†œåœºçš„ä¸»äººè®¾å®šäº†ä¸€äº›ä¸¥æ ¼çš„è§„çŸ©ï¼Œä½ å¿…é¡»æŒ‰ç…§è¦æ±‚é‡‡æ‘˜æ°´æœï¼š

1.ä½ åªæœ‰ ä¸¤ä¸ª ç¯®å­ï¼Œå¹¶ä¸”æ¯ä¸ªç¯®å­åªèƒ½è£… å•ä¸€ç±»å‹ çš„æ°´æœã€‚æ¯ä¸ªç¯®å­èƒ½å¤Ÿè£…çš„æ°´æœæ€»é‡æ²¡æœ‰é™åˆ¶ã€‚
2.ä½ å¯ä»¥é€‰æ‹©ä»»æ„ä¸€æ£µæ ‘å¼€å§‹é‡‡æ‘˜ï¼Œä½ å¿…é¡»ä» æ¯æ£µ æ ‘ï¼ˆåŒ…æ‹¬å¼€å§‹é‡‡æ‘˜çš„æ ‘ï¼‰ä¸Š æ°å¥½æ‘˜ä¸€ä¸ªæ°´æœ ã€‚é‡‡æ‘˜çš„æ°´æœåº”å½“ç¬¦åˆç¯®å­ä¸­çš„æ°´æœç±»å‹ã€‚æ¯é‡‡æ‘˜ä¸€æ¬¡ï¼Œä½ å°†ä¼šå‘å³ç§»åŠ¨åˆ°ä¸‹ä¸€æ£µæ ‘ï¼Œå¹¶ç»§ç»­é‡‡æ‘˜ã€‚
3.ä¸€æ—¦ä½ èµ°åˆ°æŸæ£µæ ‘å‰ï¼Œä½†æ°´æœä¸ç¬¦åˆç¯®å­çš„æ°´æœç±»å‹ï¼Œé‚£ä¹ˆå°±å¿…é¡»åœæ­¢é‡‡æ‘˜ã€‚

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ fruits ï¼Œè¿”å›ä½ å¯ä»¥æ”¶é›†çš„æ°´æœçš„ æœ€å¤§ æ•°ç›®ã€‚
```

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int ans =0;
        unordered_map<int ,int> cnt;
        for(int i=0,j=0,s=0;i<fruits.size();i++){
            if(++cnt[fruits[i]]==1)//å½“é‡åˆ°ä¸€ä¸ªæ–°æ°´æœæ—¶ï¼Œå°†å…¶åŠ å…¥å“ˆå¸Œè¡¨ä¸­
                s++;//é‚£ä¹ˆç¯®å­ä¸­æ°´æœç§ç±»æ•°så°±è¦åŠ 1
            while(s>2)//å¦‚æœæ°´æœç§ç±»è¶…è¿‡2
            {
                if(-- cnt[fruits[j]]==0)
                {
                    s--;
                }
                j++;
            }
            ans =max(ans,i-j+1);
        }
        return ans;;
    }
};
```

```
å…·ä½“çš„å®ç°æ€è·¯æ˜¯ï¼š

1.å®šä¹‰ä¸€ä¸ªå“ˆå¸Œè¡¨ cntï¼Œç”¨æ¥è®°å½•å½“å‰åŒºé—´å†…ä¸åŒæ°´æœçš„æ•°é‡ã€‚
2.éå† fruits æ•°ç»„ï¼Œå½“é‡åˆ°ä¸€ä¸ªæ–°æ°´æœæ—¶ï¼Œå°†å…¶åŠ å…¥å“ˆå¸Œè¡¨ä¸­ï¼Œå¹¶å°†ä¸åŒæ°´æœæ•°é‡ s åŠ 1ã€‚
3.å¦‚æœå½“å‰åŒºé—´å†…ä¸åŒæ°´æœæ•°é‡è¶…è¿‡ 2ï¼Œè¯´æ˜è¦å°†åŒºé—´ç¼©å°ï¼Œæ­¤æ—¶éœ€è¦å°†å·¦ç«¯ç‚¹ j å³ç§»ï¼Œå¹¶ä»å“ˆå¸Œè¡¨ä¸­ç§»é™¤å¯¹åº”çš„æ°´æœã€‚å¦‚æœç§»é™¤è¯¥æ°´æœåï¼Œå½“å‰åŒºé—´å†…è¯¥ç§æ°´æœæ•°é‡ä¸º 0ï¼Œåˆ™å°†ä¸åŒæ°´æœæ•°é‡ s å‡1ã€‚
4.åœ¨åŒºé—´ç¼©å°çš„è¿‡ç¨‹ä¸­ï¼Œè®°å½•ä¸‹æ¯ä¸€æ¬¡åŒºé—´çš„é•¿åº¦ï¼Œå–æœ€å¤§å€¼ä½œä¸ºç­”æ¡ˆã€‚

è¿™ä¸ªç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)ï¼Œå…¶ä¸­ n æ˜¯ fruits æ•°ç»„çš„é•¿åº¦ã€‚
```

## ç¬¬å››å¤©

### [76. æœ€å°è¦†ç›–å­ä¸²](https://leetcode.cn/problems/minimum-window-substring/)

```
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ã€ä¸€ä¸ªå­—ç¬¦ä¸² t ã€‚è¿”å› s ä¸­æ¶µç›– t æ‰€æœ‰å­—ç¬¦çš„æœ€å°å­ä¸²ã€‚å¦‚æœ s ä¸­ä¸å­˜åœ¨æ¶µç›– t æ‰€æœ‰å­—ç¬¦çš„å­ä¸²ï¼Œåˆ™è¿”å›ç©ºå­—ç¬¦ä¸² "" ã€‚
æ³¨æ„ï¼š
å¯¹äº t ä¸­é‡å¤å­—ç¬¦ï¼Œæˆ‘ä»¬å¯»æ‰¾çš„å­å­—ç¬¦ä¸²ä¸­è¯¥å­—ç¬¦æ•°é‡å¿…é¡»ä¸å°‘äº t ä¸­è¯¥å­—ç¬¦æ•°é‡ã€‚
å¦‚æœ s ä¸­å­˜åœ¨è¿™æ ·çš„å­ä¸²ï¼Œæˆ‘ä»¬ä¿è¯å®ƒæ˜¯å”¯ä¸€çš„ç­”æ¡ˆã€‚
ç¤ºä¾‹ï¼š
è¾“å…¥ï¼šs = "ADOBECODEBANC", t = "ABC"
è¾“å‡ºï¼š"BANC"
è§£é‡Šï¼šæœ€å°è¦†ç›–å­ä¸² "BANC" åŒ…å«æ¥è‡ªå­—ç¬¦ä¸² t çš„ 'A'ã€'B' å’Œ 'C'ã€‚
```



```c++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) {
            need[c]++;
        }
        int left = 0, right = 0;
        int valid = 0;
        int start = 0, len = INT_MAX;

        while (right < s.size()) {
            char c = s[right];
            right++;

            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c]) {
                    valid++;
                }
            }
            while (valid == need.size()) {
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                char d = s[left];
                left++;

                if (need.count(d)) {
                    if (window[d] == need[d]) {
                        valid--;
                    }
                    window[d]--;
                }
            }
        }
        return len == INT_MAX ? "" : s.substr(start, len);
    }
};

```

```
å…¶ä¸­ï¼Œneed æ˜¯éœ€è¦åŒ¹é…çš„å­—ç¬¦çš„è®¡æ•°è¡¨ï¼Œwindow æ˜¯å½“å‰çª—å£ä¸­çš„å­—ç¬¦è®¡æ•°è¡¨ã€‚valid è®°å½•çª—å£ä¸­å·²ç»åŒ¹é…çš„å­—ç¬¦æ•°ã€‚start å’Œ len è®°å½•æœ€å°çª—å£çš„èµ·å§‹ä½ç½®å’Œé•¿åº¦ã€‚

å…·ä½“å®ç°è¿‡ç¨‹å¦‚ä¸‹ï¼š

1.åˆå§‹åŒ– need è®¡æ•°è¡¨ï¼Œå…¶ä¸­å°† t ä¸­çš„æ¯ä¸ªå­—ç¬¦è®¡æ•°ï¼›
2.åˆå§‹åŒ–çª—å£å·¦å³æŒ‡é’ˆ left å’Œ right ä¸º 0ï¼Œvalid ä¸º 0ï¼›
3.åœ¨å³æŒ‡é’ˆå°äºå­—ç¬¦ä¸² s çš„é•¿åº¦çš„æ¡ä»¶ä¸‹ï¼Œé€æ­¥å¢åŠ å³æŒ‡é’ˆ rightï¼›
4.å½“å³æŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦æ˜¯éœ€è¦åŒ¹é…çš„å­—ç¬¦æ—¶ï¼Œæ›´æ–°çª—å£ä¸­è¯¥å­—ç¬¦çš„è®¡æ•° window[c]ï¼Œå¹¶åˆ¤æ–­å½“å‰çª—å£æ˜¯å¦å·²ç»åŒ¹é…äº†ä¸€ä¸ªå­—ç¬¦ validï¼›
5.å½“çª—å£ä¸­å·²ç»åŒ¹é…äº†æ‰€æœ‰éœ€è¦åŒ¹é…çš„å­—ç¬¦æ—¶ï¼Œè®°å½•å½“å‰æœ€å°çš„çª—å£èµ·å§‹ä½ç½®å’Œé•¿åº¦ start å’Œ lenï¼›
6.åœ¨çª—å£å·²ç»åŒ¹é…æ‰€æœ‰éœ€è¦åŒ¹é…çš„å­—ç¬¦çš„æ¡ä»¶ä¸‹ï¼Œé€æ­¥å¢åŠ å·¦æŒ‡é’ˆ leftï¼›
7.å½“å·¦æŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦æ˜¯éœ€è¦åŒ¹é…çš„å­—ç¬¦æ—¶ï¼Œæ›´æ–°çª—å£ä¸­è¯¥å­—ç¬¦çš„è®¡æ•° window[d]ï¼Œå¹¶åˆ¤æ–­å½“å‰çª—å£æ˜¯å¦ä»ç„¶åŒ¹é…äº†ä¸€ä¸ªå­—ç¬¦ validï¼›
8.é‡å¤æ­¥éª¤ 3~7ï¼Œç›´åˆ°å³æŒ‡é’ˆæŒ‡å‘å­—ç¬¦ä¸² s çš„æœ«å°¾ã€‚
æœ€åï¼Œå¦‚æœå­˜åœ¨æœ€å°çª—å£ï¼Œåˆ™è¿”å›å…¶å¯¹åº”çš„å­ä¸²ï¼›å¦åˆ™è¿”å›ç©ºä¸²ã€‚
```

### [59. èºæ—‹çŸ©é˜µ II](https://leetcode.cn/problems/spiral-matrix-ii/)

```
ç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° n ï¼Œç”Ÿæˆä¸€ä¸ªåŒ…å« 1 åˆ° n2 æ‰€æœ‰å…ƒç´ ï¼Œä¸”å…ƒç´ æŒ‰é¡ºæ—¶é’ˆé¡ºåºèºæ—‹æ’åˆ—çš„ n x n æ­£æ–¹å½¢çŸ©é˜µ matrix ã€‚
```

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> matrix(n, vector<int>(n)); // å®šä¹‰n * nçŸ©é˜µï¼Œåˆå§‹åŒ–ä¸º0
        int left = 0, right = n - 1, top = 0, bottom = n - 1; // åˆå§‹åŒ–è¾¹ç•Œ
        int num = 1; // åˆå§‹åŒ–å¡«å……æ•°å­—ä¸º1
        while (left <= right && top <= bottom) {
            for (int i = left; i <= right; i++)
                matrix[top][i] = num++; // ä»å·¦åˆ°å³
            for (int i = top + 1; i <= bottom; i++)
                matrix[i][right] = num++; // ä»ä¸Šåˆ°ä¸‹
            if (left < right && top < bottom) { // é˜²æ­¢é‡å¤
                for (int i = right - 1; i > left; i--) 
                    matrix[bottom][i] = num++; // ä»å³åˆ°å·¦
                for (int i = bottom; i > top; i--)
                    matrix[i][left] = num++; // ä»ä¸‹åˆ°ä¸Š
            }
            left++; right--; top++; bottom--; // æ›´æ–°è¾¹ç•Œ
        }
        return matrix;
    }
};

```

```
é¦–å…ˆå®šä¹‰ä¸€ä¸ªn * nçš„çŸ©é˜µï¼Œåˆå§‹åŒ–ä¸º0ï¼Œç„¶åæ¨¡æ‹Ÿèºæ—‹å¡«å……æ•°å­—çš„è¿‡ç¨‹ã€‚å¯¹äºå½“å‰çŸ©é˜µçš„å››ä¸ªè¾¹ç•Œï¼ˆå·¦ã€å³ã€ä¸Šã€ä¸‹ï¼‰ï¼Œåˆ†åˆ«æŒ‰ç…§ä»å·¦åˆ°å³ã€ä»ä¸Šåˆ°ä¸‹ã€ä»å³åˆ°å·¦ã€ä»ä¸‹åˆ°ä¸Šçš„é¡ºåºå¡«å……æ•°å­—ï¼Œç›´åˆ°æ‰€æœ‰æ•°å­—éƒ½è¢«å¡«å……å®Œä¸ºæ­¢ã€‚åŒæ—¶ï¼Œä¸æ–­æ›´æ–°çŸ©é˜µçš„è¾¹ç•Œï¼Œé˜²æ­¢é‡å¤å¡«å……æ•°å­—ã€‚æœ€åè¿”å›å¡«å……å¥½çš„çŸ©é˜µå³å¯ã€‚
```

## ç¬¬äº”å¤©

### [54. èºæ—‹çŸ©é˜µ](https://leetcode.cn/problems/spiral-matrix/)

```
ç»™ä½ ä¸€ä¸ª m è¡Œ n åˆ—çš„çŸ©é˜µ matrix ï¼Œè¯·æŒ‰ç…§ é¡ºæ—¶é’ˆèºæ—‹é¡ºåº ï¼Œè¿”å›çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚
```

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;  // å®šä¹‰ç»“æœæ•°ç»„
        if (matrix.empty()) {  // å¦‚æœçŸ©é˜µä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å›ç»“æœæ•°ç»„
            return res;
        }
        int m = matrix.size(), n = matrix[0].size();  // è·å–çŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°
        int left = 0, right = n - 1, top = 0, bottom = m - 1;  // å®šä¹‰å·¦ã€å³ã€ä¸Šã€ä¸‹è¾¹ç•Œ
        while (left <= right && top <= bottom) {  // åªè¦è¿˜æœ‰å…ƒç´ éœ€è¦éå†ï¼Œå°±ç»§ç»­è¿›è¡Œå¾ªç¯
            for (int j = left; j <= right; j++) {  // ä»å·¦åˆ°å³éå†ä¸Šè¾¹ç•Œ
                res.push_back(matrix[top][j]);  // å°†éå†åˆ°çš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­
            }
            for (int i = top + 1; i <= bottom; i++) {  // ä»ä¸Šåˆ°ä¸‹éå†å³è¾¹ç•Œ
                res.push_back(matrix[i][right]);  // å°†éå†åˆ°çš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­
            }
            if (left < right && top < bottom) {  // å¦‚æœå½“å‰çŸ©é˜µçš„å·¦è¾¹ç•Œå°äºå³è¾¹ç•Œï¼Œå¹¶ä¸”ä¸Šè¾¹ç•Œå°äºä¸‹è¾¹ç•Œ
                for (int j = right - 1; j >= left; j--) {  // ä»å³åˆ°å·¦éå†ä¸‹è¾¹ç•Œ
                    res.push_back(matrix[bottom][j]);  // å°†éå†åˆ°çš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­
                }
                for (int i = bottom - 1; i > top; i--) {  // ä»ä¸‹åˆ°ä¸Šéå†å·¦è¾¹ç•Œ
                    res.push_back(matrix[i][left]);  // å°†éå†åˆ°çš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­
                }
            }
            left++;  // æ›´æ–°å·¦è¾¹ç•Œ
            right--;  // æ›´æ–°å³è¾¹ç•Œ
            top++;  // æ›´æ–°ä¸Šè¾¹ç•Œ
            bottom--;  // æ›´æ–°ä¸‹è¾¹ç•Œ
        }
        return res;  // è¿”å›ç»“æœæ•°ç»„
    }
};
```

```
1.å®šä¹‰å››ä¸ªå˜é‡ leftã€rightã€topã€bottomï¼Œåˆ†åˆ«è¡¨ç¤ºå½“å‰è¦éå†çš„çŸ©é˜µçš„å·¦è¾¹ç•Œã€å³è¾¹ç•Œã€ä¸Šè¾¹ç•Œã€ä¸‹è¾¹ç•Œã€‚
2.æŒ‰ç…§ä»¥ä¸‹é¡ºåºéå†çŸ©é˜µï¼Œå¹¶å°†éå†çš„å…ƒç´ æŒ‰ç…§é¡ºåºå­˜å…¥ç»“æœæ•°ç»„ä¸­ï¼š
	1.ä»å·¦åˆ°å³éå†ä¸Šè¾¹ç•Œï¼Œå°†ä¸Šè¾¹ç•Œä¸Šçš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­ã€‚
	2.ä»ä¸Šåˆ°ä¸‹éå†å³è¾¹ç•Œï¼Œå°†å³è¾¹ç•Œä¸Šçš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­ã€‚
	3.å¦‚æœå½“å‰çŸ©é˜µçš„å·¦è¾¹ç•Œå°äºå³è¾¹ç•Œï¼Œå¹¶ä¸”ä¸Šè¾¹ç•Œå°äºä¸‹è¾¹ç•Œï¼Œåˆ™ä»å³åˆ°å·¦éå†ä¸‹è¾¹ç•Œï¼Œå°†ä¸‹è¾¹ç•Œä¸Šçš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­ã€‚
	4.å¦‚æœå½“å‰çŸ©é˜µçš„ä¸Šè¾¹ç•Œå°äºä¸‹è¾¹ç•Œï¼Œå¹¶ä¸”å·¦è¾¹ç•Œå°äºå³è¾¹ç•Œï¼Œåˆ™ä»ä¸‹åˆ°ä¸Šéå†å·¦è¾¹ç•Œï¼Œå°†å·¦è¾¹ç•Œä¸Šçš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­ã€‚
	5.æ›´æ–°å·¦ã€å³ã€ä¸Šã€ä¸‹è¾¹ç•Œçš„å€¼ï¼Œç»§ç»­è¿›è¡Œä¸‹ä¸€è½®éå†ï¼Œç›´åˆ°éå†å®Œæ•´ä¸ªçŸ©é˜µã€‚
```

### [å‰‘æŒ‡ Offer 29. é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

```
è¾“å…¥ä¸€ä¸ªçŸ©é˜µï¼ŒæŒ‰ç…§ä»å¤–å‘é‡Œä»¥é¡ºæ—¶é’ˆçš„é¡ºåºä¾æ¬¡æ‰“å°å‡ºæ¯ä¸€ä¸ªæ•°å­—ã€‚
```

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;  // å®šä¹‰ç»“æœæ•°ç»„
        if (matrix.empty()) {  // å¦‚æœçŸ©é˜µä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å›ç»“æœæ•°ç»„
            return res;
        }
        int m = matrix.size(), n = matrix[0].size();  // è·å–çŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°
        int left = 0, right = n - 1, top = 0, bottom = m - 1;  // å®šä¹‰å·¦ã€å³ã€ä¸Šã€ä¸‹è¾¹ç•Œ
        while (left <= right && top <= bottom) {  // åªè¦è¿˜æœ‰å…ƒç´ éœ€è¦éå†ï¼Œå°±ç»§ç»­è¿›è¡Œå¾ªç¯
            for (int j = left; j <= right; j++) {  // ä»å·¦åˆ°å³éå†ä¸Šè¾¹ç•Œ
                res.push_back(matrix[top][j]);  // å°†éå†åˆ°çš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­
            }
            for (int i = top + 1; i <= bottom; i++) {  // ä»ä¸Šåˆ°ä¸‹éå†å³è¾¹ç•Œ
                res.push_back(matrix[i][right]);  // å°†éå†åˆ°çš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­
            }
            if (left < right && top < bottom) {  // å¦‚æœå½“å‰çŸ©é˜µçš„å·¦è¾¹ç•Œå°äºå³è¾¹ç•Œï¼Œå¹¶ä¸”ä¸Šè¾¹ç•Œå°äºä¸‹è¾¹ç•Œ
                for (int j = right - 1; j >= left; j--) {  // ä»å³åˆ°å·¦éå†ä¸‹è¾¹ç•Œ
                    res.push_back(matrix[bottom][j]);  // å°†éå†åˆ°çš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­
                }
                for (int i = bottom - 1; i > top; i--) {  // ä»ä¸‹åˆ°ä¸Šéå†å·¦è¾¹ç•Œ
                    res.push_back(matrix[i][left]);  // å°†éå†åˆ°çš„å…ƒç´ åŠ å…¥ç»“æœæ•°ç»„ä¸­
                }
            }
            left++;  // æ›´æ–°å·¦è¾¹ç•Œ
            right--;  // æ›´æ–°å³è¾¹ç•Œ
            top++;  // æ›´æ–°ä¸Šè¾¹ç•Œ
            bottom--;  // æ›´æ–°ä¸‹è¾¹ç•Œ
        }
        return res;  // è¿”å›ç»“æœæ•°ç»„
    }
};
```

```
æ€è·¯ä¸ä¸Šé¢˜ç›¸åŒï¼Œä¸å†èµ˜è¿°
```

## ç¬¬äº”å¤©

### [203. ç§»é™¤é“¾è¡¨å…ƒç´ ](https://leetcode.cn/problems/remove-linked-list-elements/)

```
ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head å’Œä¸€ä¸ªæ•´æ•° val ï¼Œè¯·ä½ åˆ é™¤é“¾è¡¨ä¸­æ‰€æœ‰æ»¡è¶³ Node.val == val çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å› æ–°çš„å¤´èŠ‚ç‚¹ ã€‚
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummy = new ListNode(0);  // å®šä¹‰è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œæ–¹ä¾¿å¤„ç†å¤´èŠ‚ç‚¹å°±æ˜¯å¾…åˆ é™¤èŠ‚ç‚¹çš„æƒ…å†µ
        dummy->next = head;  // å°†è™šæ‹Ÿå¤´èŠ‚ç‚¹è¿æ¥åˆ°çœŸæ­£çš„å¤´èŠ‚ç‚¹ä¹‹å‰
        ListNode* cur = dummy;  // å®šä¹‰å½“å‰èŠ‚ç‚¹æŒ‡é’ˆï¼Œåˆå§‹æŒ‡å‘è™šæ‹Ÿå¤´èŠ‚ç‚¹
        while (cur->next) {  // åªè¦å½“å‰èŠ‚ç‚¹åé¢è¿˜æœ‰èŠ‚ç‚¹ï¼Œå°±ç»§ç»­éå†
            if (cur->next->val == val) {  // å¦‚æœå½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å€¼ä¸º valï¼Œåˆ™å°†å…¶åˆ é™¤
                ListNode* temp = cur->next;  // å®šä¹‰ä¸´æ—¶èŠ‚ç‚¹æŒ‡é’ˆï¼ŒæŒ‡å‘éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹
                cur->next = cur->next->next;  // å°†å½“å‰èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                delete temp;  // é‡Šæ”¾éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹
            } else {  // å¦‚æœå½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å€¼ä¸ä¸º valï¼Œåˆ™å°†å½“å‰èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                cur = cur->next;
            }
        }
        ListNode* newHead = dummy->next;  // å°†æ–°çš„å¤´èŠ‚ç‚¹æŒ‡å‘è™šæ‹Ÿå¤´èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        delete dummy;  // é‡Šæ”¾è™šæ‹Ÿå¤´èŠ‚ç‚¹
        return newHead;  // è¿”å›æ–°çš„å¤´èŠ‚ç‚¹
    }
};

```

```
ä¸»è¦æ€è·¯æ˜¯ä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹æ¥ç®€åŒ–åˆ é™¤å¤´èŠ‚ç‚¹çš„æ“ä½œï¼Œå¹¶ä½¿ç”¨å½“å‰èŠ‚ç‚¹æŒ‡é’ˆæ¥éå†é“¾è¡¨ï¼Œå¯¹èŠ‚ç‚¹å€¼ä¸º val çš„èŠ‚ç‚¹è¿›è¡Œåˆ é™¤æ“ä½œã€‚
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“æ‰€æœ‰èŠ‚ç‚¹éƒ½æ˜¯å¾…åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œéœ€è¦ä¿è¯ä»£ç çš„æ­£ç¡®æ€§ï¼Œé¿å…å‡ºç°é‡æŒ‡é’ˆç­‰é”™è¯¯ã€‚
```

## ç¬¬å…­å¤©

### [707. è®¾è®¡é“¾è¡¨](https://leetcode.cn/problems/design-linked-list/)

```
ä½ å¯ä»¥é€‰æ‹©ä½¿ç”¨å•é“¾è¡¨æˆ–è€…åŒé“¾è¡¨ï¼Œè®¾è®¡å¹¶å®ç°è‡ªå·±çš„é“¾è¡¨ã€‚

å•é“¾è¡¨ä¸­çš„èŠ‚ç‚¹åº”è¯¥å…·å¤‡ä¸¤ä¸ªå±æ€§ï¼šval å’Œ next ã€‚val æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œnext æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ/å¼•ç”¨ã€‚

å¦‚æœæ˜¯åŒå‘é“¾è¡¨ï¼Œåˆ™è¿˜éœ€è¦å±æ€§ prev ä»¥æŒ‡ç¤ºé“¾è¡¨ä¸­çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ã€‚å‡è®¾é“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ä¸‹æ ‡ä» 0 å¼€å§‹ã€‚

å®ç° MyLinkedList ç±»ï¼š

1.MyLinkedList() åˆå§‹åŒ– MyLinkedList å¯¹è±¡ã€‚
2.int get(int index) è·å–é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœä¸‹æ ‡æ— æ•ˆï¼Œåˆ™è¿”å› -1 ã€‚
3.void addAtHead(int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰ã€‚åœ¨æ’å…¥å®Œæˆåï¼Œæ–°èŠ‚ç‚¹ä¼šæˆä¸ºé“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚
4.void addAtTail(int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹è¿½åŠ åˆ°é“¾è¡¨ä¸­ä½œä¸ºé“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚
5.void addAtIndex(int index, int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹ä¹‹å‰ã€‚å¦‚æœ index ç­‰äºé“¾è¡¨çš„é•¿åº¦ï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹ä¼šè¢«è¿½åŠ åˆ°é“¾è¡¨çš„æœ«å°¾ã€‚å¦‚æœ index æ¯”é•¿åº¦æ›´å¤§ï¼Œè¯¥èŠ‚ç‚¹å°† ä¸ä¼šæ’å…¥ åˆ°é“¾è¡¨ä¸­ã€‚
6.void deleteAtIndex(int index) å¦‚æœä¸‹æ ‡æœ‰æ•ˆï¼Œåˆ™åˆ é™¤é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹ã€‚
```

```c++
class MyLinkedList {
public:
    // å®šä¹‰é“¾è¡¨èŠ‚ç‚¹ç»“æ„ä½“
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // åˆå§‹åŒ–é“¾è¡¨
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // è¿™é‡Œå®šä¹‰çš„å¤´ç»“ç‚¹ æ˜¯ä¸€ä¸ªè™šæ‹Ÿå¤´ç»“ç‚¹ï¼Œè€Œä¸æ˜¯çœŸæ­£çš„é“¾è¡¨å¤´ç»“ç‚¹
        _size = 0;
    }

    // è·å–åˆ°ç¬¬indexä¸ªèŠ‚ç‚¹æ•°å€¼ï¼Œå¦‚æœindexæ˜¯éæ³•æ•°å€¼ç›´æ¥è¿”å›-1ï¼Œ æ³¨æ„indexæ˜¯ä»0å¼€å§‹çš„ï¼Œç¬¬0ä¸ªèŠ‚ç‚¹å°±æ˜¯å¤´ç»“ç‚¹
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--){ // å¦‚æœ--index å°±ä¼šé™·å…¥æ­»å¾ªç¯
            cur = cur->next;
        }
        return cur->val;
    }

    // åœ¨é“¾è¡¨æœ€å‰é¢æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ’å…¥å®Œæˆåï¼Œæ–°æ’å…¥çš„èŠ‚ç‚¹ä¸ºé“¾è¡¨çš„æ–°çš„å¤´ç»“ç‚¹
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // åœ¨é“¾è¡¨æœ€åé¢æ·»åŠ ä¸€ä¸ªèŠ‚ç‚¹
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // åœ¨ç¬¬indexä¸ªèŠ‚ç‚¹ä¹‹å‰æ’å…¥ä¸€ä¸ªæ–°èŠ‚ç‚¹ï¼Œä¾‹å¦‚indexä¸º0ï¼Œé‚£ä¹ˆæ–°æ’å…¥çš„èŠ‚ç‚¹ä¸ºé“¾è¡¨çš„æ–°å¤´èŠ‚ç‚¹ã€‚
    // å¦‚æœindex ç­‰äºé“¾è¡¨çš„é•¿åº¦ï¼Œåˆ™è¯´æ˜æ˜¯æ–°æ’å…¥çš„èŠ‚ç‚¹ä¸ºé“¾è¡¨çš„å°¾ç»“ç‚¹
    // å¦‚æœindexå¤§äºé“¾è¡¨çš„é•¿åº¦ï¼Œåˆ™è¿”å›ç©º
    // å¦‚æœindexå°äº0ï¼Œåˆ™åœ¨å¤´éƒ¨æ’å…¥èŠ‚ç‚¹
    void addAtIndex(int index, int val) {

        if(index > _size) return;
        if(index < 0) index = 0;        
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // åˆ é™¤ç¬¬indexä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœindex å¤§äºç­‰äºé“¾è¡¨çš„é•¿åº¦ï¼Œç›´æ¥returnï¼Œæ³¨æ„indexæ˜¯ä»0å¼€å§‹çš„
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        //deleteå‘½ä»¤æŒ‡ç¤ºé‡Šæ”¾äº†tmpæŒ‡é’ˆåŸæœ¬æ‰€æŒ‡çš„é‚£éƒ¨åˆ†å†…å­˜ï¼Œ
        //è¢«deleteåçš„æŒ‡é’ˆtmpçš„å€¼ï¼ˆåœ°å€ï¼‰å¹¶éå°±æ˜¯NULLï¼Œè€Œæ˜¯éšæœºå€¼ã€‚ä¹Ÿå°±æ˜¯è¢«deleteåï¼Œ
        //å¦‚æœä¸å†åŠ ä¸Šä¸€å¥tmp=nullptr,tmpä¼šæˆä¸ºä¹±æŒ‡çš„é‡æŒ‡é’ˆ
        //å¦‚æœä¹‹åçš„ç¨‹åºä¸å°å¿ƒä½¿ç”¨äº†tmpï¼Œä¼šæŒ‡å‘éš¾ä»¥é¢„æƒ³çš„å†…å­˜ç©ºé—´
        tmp=nullptr;
        _size--;
    }

    // æ‰“å°é“¾è¡¨
    void printLinkedList() {
        LinkedNode* cur = _dummyHead;
        while (cur->next != nullptr) {
            cout << cur->next->val << " ";
            cur = cur->next;
        }
        cout << endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;
};
```

### [206. åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)

```
ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        ListNode* prev = nullptr;
        ListNode* curr = head;
        ListNode* next = nullptr;
        while (curr != nullptr) {
            next = curr->next;  // æš‚å­˜å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            curr->next = prev;  // åè½¬å½“å‰èŠ‚ç‚¹çš„æŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
            prev = curr;        // æ›´æ–°å‰ä¸€ä¸ªèŠ‚ç‚¹
            curr = next;        // æ›´æ–°å½“å‰èŠ‚ç‚¹
        }
        return prev;  // è¿”å›åè½¬åçš„å¤´èŠ‚ç‚¹
    }
};

```

```
1.åˆå§‹åŒ–ä¸‰ä¸ªæŒ‡é’ˆå˜é‡ï¼Œåˆ†åˆ«æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ã€å½“å‰èŠ‚ç‚¹å’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ
	åˆå§‹æ—¶å‰ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ç©ºï¼Œå½“å‰èŠ‚ç‚¹æŒ‡å‘å¤´èŠ‚ç‚¹ï¼Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ç©ºï¼›
2.å¯¹äºå½“å‰èŠ‚ç‚¹ï¼Œå°†å®ƒçš„æŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ
	ç„¶åæ›´æ–°å‰ä¸€ä¸ªèŠ‚ç‚¹ä¸ºå½“å‰èŠ‚ç‚¹ï¼Œå½“å‰èŠ‚ç‚¹ä¸ºä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼›
3.é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°å½“å‰èŠ‚ç‚¹ä¸ºnullptrï¼Œ
	æ­¤æ—¶åè½¬å®Œæˆï¼Œè¿”å›å‰ä¸€ä¸ªèŠ‚ç‚¹å³ä¸ºåè½¬åçš„å¤´èŠ‚ç‚¹ã€‚
```

## ç¬¬ä¸ƒå¤©

### [24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```
ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚
ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0);  // åˆ›å»ºè™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œæ–¹ä¾¿å¤„ç†å¤´èŠ‚ç‚¹
        dummyHead->next=head;  // å°†è™šæ‹Ÿå¤´èŠ‚ç‚¹æŒ‡å‘åŸå¤´èŠ‚ç‚¹
        ListNode* cur =dummyHead;  // curæŒ‡é’ˆåˆå§‹åŒ–ä¸ºè™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œæ–¹ä¾¿éå†é“¾è¡¨
        while(cur->next!=nullptr&&cur->next->next!=nullptr){  // å½“å‰èŠ‚ç‚¹å’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºæ—¶è¿›è¡Œäº¤æ¢æ“ä½œ
            ListNode* temp= cur->next;  // ä¿å­˜å½“å‰èŠ‚ç‚¹
            ListNode* temp1= cur->next->next->next;  // ä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹

            cur->next=cur->next->next;  // å½“å‰èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            cur->next->next=temp;  // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘å½“å‰èŠ‚ç‚¹
            cur->next->next->next=temp1;  // å½“å‰èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹

            cur=cur->next->next;  // curæŒ‡å‘äº¤æ¢åçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç»§ç»­éå†é“¾è¡¨
        }
        return dummyHead->next;  // è¿”å›äº¤æ¢åçš„é“¾è¡¨
    }
};

```

```
1.åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼ŒæŒ‡å‘åŸé“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œæ–¹ä¾¿å¤„ç†å¤´èŠ‚ç‚¹ï¼›
2.åˆå§‹åŒ–ä¸€ä¸ªcuræŒ‡é’ˆï¼ŒæŒ‡å‘è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œæ–¹ä¾¿éå†é“¾è¡¨ï¼›
3.éå†é“¾è¡¨ï¼Œå½“å½“å‰èŠ‚ç‚¹å’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºæ—¶ï¼Œè¿›è¡Œäº¤æ¢æ“ä½œï¼›
4.äº¤æ¢æ“ä½œåˆ†åˆ«æ˜¯ï¼šä¿å­˜å½“å‰èŠ‚ç‚¹å’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°†å½“å‰èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ
ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘å½“å‰èŠ‚ç‚¹ï¼Œå½“å‰èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼›
5.æ›´æ–°curæŒ‡é’ˆï¼ŒæŒ‡å‘äº¤æ¢åçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼›
6.è¿”å›äº¤æ¢åçš„é“¾è¡¨ã€‚
```

### [19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```
ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚
è¿›é˜¶ï¼šä½ èƒ½å°è¯•ä½¿ç”¨ä¸€è¶Ÿæ‰«æå®ç°å—ï¼Ÿ
æç¤ºï¼š
åŒæŒ‡é’ˆçš„ç»å…¸åº”ç”¨ï¼Œå¦‚æœè¦åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹ï¼Œè®©fastç§»åŠ¨næ­¥ï¼Œç„¶åè®©fastå’ŒslowåŒæ—¶ç§»åŠ¨ï¼Œç›´åˆ°fastæŒ‡å‘é“¾è¡¨æœ«å°¾ã€‚åˆ æ‰slowæ‰€æŒ‡å‘çš„èŠ‚ç‚¹å°±å¯ä»¥äº†ã€‚
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // åˆ›å»ºè™šæ‹Ÿå¤´èŠ‚ç‚¹
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        // åˆ›å»ºå¿«æ…¢æŒ‡é’ˆï¼Œåˆå§‹éƒ½æŒ‡å‘è™šæ‹Ÿå¤´èŠ‚ç‚¹
        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;
        // è®©å¿«æŒ‡é’ˆå…ˆèµ°næ­¥
        while (n-- && fast != nullptr) {
            fast = fast->next;
        }
        // è®©å¿«æŒ‡é’ˆå†æå‰èµ°ä¸€æ­¥ï¼Œå› ä¸ºéœ€è¦è®©æ…¢æŒ‡é’ˆæŒ‡å‘åˆ é™¤èŠ‚ç‚¹çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹
        fast = fast->next;
        // å¿«æ…¢æŒ‡é’ˆä¸€èµ·èµ°ï¼Œç›´åˆ°å¿«æŒ‡é’ˆåˆ°è¾¾é“¾è¡¨å°¾éƒ¨
        while (fast != nullptr) {
            fast = fast->next;
            slow = slow->next;
        }
        // åˆ é™¤èŠ‚ç‚¹
        slow->next = slow->next->next;
        // è¿”å›å¤´èŠ‚ç‚¹
        return dummyHead->next;
    }
};

```

```
è¿™é“é¢˜ç›®è¦æ±‚æˆ‘ä»¬åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹ã€‚
é¦–å…ˆæˆ‘ä»¬å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ slow å’Œ fastï¼Œ
å…ˆè®© fast èµ° n æ­¥ï¼Œç„¶åè®© slow å’Œ fast åŒæ—¶èµ°ï¼Œ
å½“ fast èµ°åˆ°é“¾è¡¨çš„å°¾éƒ¨æ—¶ï¼Œslow å°±æŒ‡å‘äº†å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ
æ­¤æ—¶æˆ‘ä»¬å¯ä»¥åˆ é™¤ slow æŒ‡å‘çš„èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹ã€‚

ä¸ºäº†é¿å…å‡ºç°åˆ é™¤å¤´èŠ‚ç‚¹çš„æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹æ¥å¤„ç†ã€‚
æˆ‘ä»¬å¯ä»¥å…ˆåˆ›å»ºä¸€ä¸ªå€¼ä¸º 0 çš„è™šæ‹Ÿå¤´èŠ‚ç‚¹ dummyHeadï¼Œå°†å®ƒçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ headï¼Œ
è¿™æ ·å°±èƒ½å¤Ÿå¤„ç†æ‰åˆ é™¤å¤´èŠ‚ç‚¹çš„æƒ…å†µäº†ã€‚æœ€åè¿”å› dummyHead çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å³å¯ã€‚
```

### [2235. ä¸¤æ•´æ•°ç›¸åŠ ](https://leetcode.cn/problems/add-two-integers/)

```
ç»™ä½ ä¸¤ä¸ªæ•´æ•° num1 å’Œ num2ï¼Œè¿”å›è¿™ä¸¤ä¸ªæ•´æ•°çš„å’Œã€‚
```

```c++
class Solution {
public:
    int sum(int num1, int num2) {
        return num1+num2;
    }
};
```

```
æ•´æ´» ğŸ˜
```

## ç¬¬å…«å¤©

### [é¢è¯•é¢˜ 02.07. é“¾è¡¨ç›¸äº¤](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

```
ç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹Â headA å’Œ headB ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤ç‚¹ï¼Œè¿”å› null ã€‚

å›¾ç¤ºä¸¤ä¸ªé“¾è¡¨åœ¨èŠ‚ç‚¹ c1 å¼€å§‹ç›¸äº¤ï¼š

é¢˜ç›®æ•°æ®ä¿è¯æ•´ä¸ªé“¾å¼ç»“æ„ä¸­ä¸å­˜åœ¨ç¯ã€‚

æ³¨æ„ï¼Œå‡½æ•°è¿”å›ç»“æœåï¼Œé“¾è¡¨å¿…é¡» ä¿æŒå…¶åŸå§‹ç»“æ„ ã€‚
```

![image-20230417205509519](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230417205509519.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA; //å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘headAå’ŒheadB
        ListNode* curB = headB;
        
        int lenA= 0,lenB=0;//åˆå§‹åŒ–ï¼Œç”±äºå­˜å‚¨é“¾è¡¨é•¿åº¦

        while(curA !=NULL){// è·å–headAçš„é•¿åº¦
            lenA++;
            curA= curA->next;
        }
        while(curB!=NULL){// è·å–headBçš„é•¿åº¦
            lenB++;
            curB= curB->next;
        }

        curA = headA;
        curB = headB;//é‡æ–°å°†curAå’ŒcurBæŒ‡å‘é“¾è¡¨çš„å¤´éƒ¨

        if(lenB>lenA){//å¦‚æœé“¾è¡¨Bçš„é•¿åº¦å¤§äºé“¾è¡¨Açš„é•¿åº¦
            swap(lenA,lenB);
            swap(curA,curB);//å°±å°†ä¸¤ä¸ªé“¾è¡¨äº¤æ¢
        }

        int g= lenA-lenB;//è®¡ç®—é•¿åº¦å·®å€¼
        
        while(g--){//æŠŠé“¾è¡¨é•¿åº¦é•¿çš„ï¼ˆå°±æ˜¯curAï¼‰å‘åç§»åŠ¨gä½
            curA =curA->next;
        }

        while(curA != NULL){//å†å¾ªç¯å¯¹æ¯”ä¸¤ä¸ªé“¾è¡¨ä½™ä¸‹çš„éƒ¨åˆ†
            if(curA==curB)return curA;//å¦‚æœèŠ‚ç‚¹åœ°å€ç›¸åŒåˆ™è¿”å›åœ°å€
            curA =curA->next;
            curB= curB->next;//å¦åˆ™åŒæ—¶å‘åç§»åŠ¨
        }
	return NULL;//æ²¡æœ‰ç›¸äº¤èŠ‚ç‚¹ï¼Œè¿”å›NULL
    }
};
```

```
ç®€å•æ¥è¯´ï¼Œå°±æ˜¯æ±‚ä¸¤ä¸ªé“¾è¡¨äº¤ç‚¹èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚
è¿™é‡Œè¦æ³¨æ„ï¼Œäº¤ç‚¹ä¸æ˜¯æ•°å€¼ç›¸ç­‰ï¼Œè€Œæ˜¯æŒ‡é’ˆç›¸ç­‰ã€‚
æˆ‘ä»¬æ±‚å‡ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ï¼Œå¹¶æ±‚å‡ºä¸¤ä¸ªé“¾è¡¨é•¿åº¦çš„å·®å€¼ï¼Œç„¶åè®©curAç§»åŠ¨åˆ°ï¼Œå’ŒcurB æœ«å°¾å¯¹é½çš„ä½ç½®ã€‚
æ­¤æ—¶æˆ‘ä»¬å°±å¯ä»¥æ¯”è¾ƒcurAå’ŒcurBæ˜¯å¦ç›¸åŒï¼Œå¦‚æœä¸ç›¸åŒï¼ŒåŒæ—¶å‘åç§»åŠ¨curAå’ŒcurBï¼Œ
å¦‚æœé‡åˆ°curA == curBï¼Œåˆ™æ‰¾åˆ°äº¤ç‚¹ã€‚
å¦åˆ™å¾ªç¯é€€å‡ºè¿”å›ç©ºæŒ‡é’ˆã€‚
```

### [142. ç¯å½¢é“¾è¡¨ II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```
ç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ Â headÂ ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚Â å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å›Â nullã€‚

å¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª next æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œè¯„æµ‹ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨æ•´æ•° pos æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚å¦‚æœ pos æ˜¯ -1ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚æ³¨æ„ï¼špos ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚

ä¸å…è®¸ä¿®æ”¹ é“¾è¡¨ã€‚
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;//å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œéƒ½æŒ‡å‘head
        ListNode* slow =head;
        while(fast!=NULL&& fast->next!=NULL){
            slow= slow->next;//slowèµ°ä¸€æ­¥
            fast= fast->next->next;//fastèµ°ä¸¤æ­¥
            if(slow==fast){//ç›¸é‡äº†
                ListNode* i1 =fast;//é‡æ–°åˆ›å»ºä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘fast,ä¹Ÿå°±æ˜¯ç›¸é‡çš„ä½ç½®
                ListNode* i2 =head;//å°†å¦ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å¤´èŠ‚ç‚¹
                while(i1!=i2){//ä¸€ç›´å¾ªç¯åˆ°å†æ¬¡ç›¸é‡
                    i1=i1->next;
                    i2=i2->next;
                }
                return i2;//ç›¸é‡çš„åœ°æ–¹å°±æ˜¯ç¯çš„å…¥å£
            }
        }
        return NULL;//æ²¡æœ‰ç¯
    }
};
```
[æ€è·¯åœ¨è¿™]([leetcode-master/0142.ç¯å½¢é“¾è¡¨II.md at master Â· youngyangyang04/leetcode-master (github.com)](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0142.ç¯å½¢é“¾è¡¨II.md))

## ç¬¬ä¹å¤©

### æ°´ä¸€å¤©ï¼Œæ²¡åˆ·é¢˜ï¼Œè¿™æ˜¯ä»Šå¤©çš„ä½œä¸š

```
å®ç°äº†äºŒå‰æ ‘é€’å½’çš„å‰ä¸­ååºéå†å’Œå¯¹åº”çš„éé€’å½’éå†
```

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
// äºŒå‰æ ‘é“¾å¼å­˜å‚¨ç»“æ„ä½“
typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
} BinaryNode, * BinaryTree;

// åˆå§‹åŒ–äºŒå‰æ ‘
void init(BinaryTree* t) {
    *t = NULL;
}

// åˆ›å»ºæ–°èŠ‚ç‚¹
BinaryNode* createNode(int x) {
    BinaryNode* node = (BinaryNode*)malloc(sizeof(BinaryNode));
    node->data = x;
    node->left = node->right = NULL;
    return node;
}

// é€šè¿‡å…ˆåºéå†åºåˆ—æ„å»ºäºŒå‰æ ‘
void build(BinaryTree* t) {
    int x;
    scanf_s("%d", &x);
    if (x == -1) {  // å½“å‰èŠ‚ç‚¹ä¸ºNULL
        *t = NULL;
    }
    else {  // å½“å‰èŠ‚ç‚¹ä¸ä¸ºNULL
        BinaryNode* node = createNode(x);
        *t = node;
        build(&(node->left));  // é€’å½’æ„å»ºå·¦å­æ ‘
        build(&(node->right));  // é€’å½’æ„å»ºå³å­æ ‘
    }
}

// é€’å½’å®ç°çš„å‰åºéå†
void preRecursionTraversal(BinaryTree t) {
    if (t != NULL) {
        printf("%d ", t->data);
        preRecursionTraversal(t->left);
        preRecursionTraversal(t->right);
    }
}
// é€’å½’å®ç°çš„ä¸­åºéå†
void midRecursionTraversal(BinaryTree t) {
    if (t != NULL) {
        midRecursionTraversal(t->left);
        printf("%d ", t->data);
        midRecursionTraversal(t->right);
    }
}
// é€’å½’å®ç°çš„ååºéå†
void postRecursionTraversal(BinaryTree t) {
    if (t != NULL) {
        postRecursionTraversal(t->left);
        postRecursionTraversal(t->right);
        printf("%d ", t->data);
    }
}

// éé€’å½’å®ç°çš„å‰åºéå†
//å‰åºéå†æ˜¯ä¸­å·¦å³ï¼Œæ¯æ¬¡å…ˆå¤„ç†çš„æ˜¯ä¸­é—´èŠ‚ç‚¹
//å…ˆå°†æ ¹èŠ‚ç‚¹æ”¾å…¥æ ˆä¸­ï¼Œç„¶åå°†å³å­©å­åŠ å…¥æ ˆï¼Œå†åŠ å…¥å·¦å­©å­
void preOrderTraversal(BinaryTree t) {
    if (t == NULL) {
        return;
    }

    BinaryNode* stack[MAX_SIZE];  // ä½¿ç”¨æ ˆæ¥ä¿å­˜èŠ‚ç‚¹
    int top = 0;

    stack[top++] = t;//å°†æ ¹èŠ‚ç‚¹å‹å…¥
    while (top > 0) {//åªè¦æ ˆä¸ä¸ºç©ºï¼Œå°±ç»§ç»­å¾ªç¯
        BinaryNode* node = stack[--top];//å–å‡ºé¡¶éƒ¨èŠ‚ç‚¹(ä¸­)
        printf("%d ", node->data);//æ‰“å°æ“ä½œ

        // å…ˆå°†å³å­æ ‘å…¥æ ˆï¼Œå†å°†å·¦å­æ ‘å…¥æ ˆï¼Œä¿è¯å·¦å­æ ‘å…ˆéå†
        if (node->right != NULL) {//å¦‚æœå³ä¸ä¸ºNULL(å³)
            stack[top++] = node->right;//å‹å…¥æ ˆé¡¶
        }
        if (node->left != NULL) {//å¦‚æœå³ä¸ä¸ºNULL(å·¦)
            stack[top++] = node->left;//å‹å…¥æ ˆé¡¶
        }
    }
}

// éé€’å½’å®ç°çš„ä¸­åºéå†
void midOrderTraversal(BinaryTree t) {
    if (t == NULL) {
        return;
    }

    BinaryNode* stack[MAX_SIZE];  // ä½¿ç”¨æ ˆæ¥ä¿å­˜èŠ‚ç‚¹
    int top = 0;

    BinaryNode* p = t;//å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œä¾¿äºæ“ä½œ
    while (p != NULL || top > 0) {
        while (p != NULL) {// æŒ‡é’ˆæ¥è®¿é—®èŠ‚ç‚¹ï¼Œè®¿é—®åˆ°æœ€åº•å±‚
            stack[top++] = p;// å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾è¿›æ ˆ
            p = p->left;//å·¦
        }
 l
        if (top > 0) {
            p = stack[--top];// ä»æ ˆé‡Œå¼¹å‡ºçš„æ•°æ®ï¼Œå°±æ˜¯è¦å¤„ç†çš„æ•°æ®
            printf("%d ", p->data);
            p = p->right;// å³
        }
    }
}

// éé€’å½’å®ç°çš„ååºéå†
void postOrderTraversal(BinaryTree t) {
    if (t == NULL) {
        return;
    }

    BinaryNode* stack[MAX_SIZE];  // ä½¿ç”¨æ ˆæ¥ä¿å­˜èŠ‚ç‚¹
    int top = 0;
    BinaryNode* lastVisited = NULL;

    BinaryNode* p = t;
    while (p != NULL || top > 0) {
        while (p != NULL) {
            stack[top++] = p;
            p = p->left;
        }

        BinaryNode* node = stack[top - 1];
        // å½“å³å­æ ‘ä¸ºç©ºæˆ–å¦‚æœå½“å‰èŠ‚ç‚¹çš„å³å­æ ‘ä¸ºç©ºï¼Œæˆ–è€…å³å­æ ‘å·²ç»è¢«è®¿é—®è¿‡ï¼Œå°±å¯ä»¥è®¿é—®å½“å‰èŠ‚ç‚¹äº†ã€‚å¦åˆ™ï¼Œå°†å³å­æ ‘å…¥æ ˆã€‚
        if (node->right == NULL || node->right == lastVisited) {
            printf("%d ", node->data);
            top--;
            lastVisited = node;
        }
        else {
            p = node->right;
        }
    }
}
int main() {
    BinaryTree t;
    init(&t);

    printf("è¯·è¾“å…¥å…ˆåºéå†åºåˆ—ï¼Œ-1è¡¨ç¤ºè¯¥ä½ç½®ä¸ºNULL: ");
    build(&t);

    printf("é€’  å½’å®ç°å‰åºéå†ç»“æœ: ");
    preRecursionTraversal(t);
    printf("\n");
    printf("éé€’å½’å®ç°å‰åºéå†ç»“æœ: ");
    preOrderTraversal(t);
    printf("\n");
    printf("é€’  å½’å®ç°ä¸­åºéå†ç»“æœ: ");
    midRecursionTraversal(t);
    printf("\n");
    printf("éé€’å½’å®ç°ä¸­åºéå†ç»“æœ: ");
    midOrderTraversal(t);
    printf("\n");
    printf("é€’  å½’å®ç°ååºéå†ç»“æœ: ");
    postRecursionTraversal(t);
    printf("\n");
    printf("éé€’å½’å®ç°ååºéå†ç»“æœ: ");
    postOrderTraversal(t);
    printf("\n");

    return 0;
}
```

## ç¬¬åå¤©

### [242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯](https://leetcode.cn/problems/valid-anagram/)

```
ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ t ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ t æ˜¯å¦æ˜¯ s çš„å­—æ¯å¼‚ä½è¯ã€‚

æ³¨æ„ï¼šè‹¥Â s å’Œ tÂ ä¸­æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°éƒ½ç›¸åŒï¼Œåˆ™ç§°Â s å’Œ tÂ äº’ä¸ºå­—æ¯å¼‚ä½è¯ã€‚
```

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int arr[26]={0};
        for(int i=0;i<s.size();i++){
            arr[s[i]-'a']++;
        }
        for(int i=0;i<t.size();i++){
            arr[t[i]-'a']--;
        }
        for(int i=0;i<26;i++){
            if(arr[i]!=0)return false;
        }
        return true;
    }
};
```

```
éœ€è¦æŠŠå­—ç¬¦æ˜ å°„åˆ°æ•°ç»„ä¹Ÿå°±æ˜¯å“ˆå¸Œè¡¨çš„ç´¢å¼•ä¸‹æ ‡ä¸Šï¼Œå› ä¸ºå­—ç¬¦aåˆ°å­—ç¬¦zçš„ASCIIæ˜¯26ä¸ªè¿ç»­çš„æ•°å€¼ï¼Œ
æ‰€ä»¥å­—ç¬¦aæ˜ å°„ä¸ºä¸‹æ ‡0ï¼Œç›¸åº”çš„å­—ç¬¦zæ˜ å°„ä¸ºä¸‹æ ‡25ã€‚
å†éå† å­—ç¬¦ä¸²sçš„æ—¶å€™ï¼Œåªéœ€è¦å°† s[i] - â€˜aâ€™ æ‰€åœ¨çš„å…ƒç´ åš+1 æ“ä½œå³å¯ï¼Œ
å¹¶ä¸éœ€è¦è®°ä½å­—ç¬¦açš„ASCIIï¼Œåªè¦æ±‚å‡ºä¸€ä¸ªç›¸å¯¹æ•°å€¼å°±å¯ä»¥äº†ã€‚ è¿™æ ·å°±å°†å­—ç¬¦ä¸²sä¸­å­—ç¬¦å‡ºç°çš„æ¬¡æ•°ï¼Œç»Ÿè®¡å‡ºæ¥äº†ã€‚
é‚£çœ‹ä¸€ä¸‹å¦‚ä½•æ£€æŸ¥å­—ç¬¦ä¸²tä¸­æ˜¯å¦å‡ºç°äº†è¿™äº›å­—ç¬¦ï¼ŒåŒæ ·åœ¨éå†å­—ç¬¦ä¸²tçš„æ—¶å€™ï¼Œ
å¯¹tä¸­å‡ºç°çš„å­—ç¬¦æ˜ å°„å“ˆå¸Œè¡¨ç´¢å¼•ä¸Šçš„æ•°å€¼å†åš-1çš„æ“ä½œã€‚
é‚£ä¹ˆæœ€åæ£€æŸ¥ä¸€ä¸‹ï¼Œarræ•°ç»„å¦‚æœæœ‰çš„å…ƒç´ ä¸ä¸ºé›¶0
ï¼Œè¯´æ˜å­—ç¬¦ä¸²så’Œtä¸€å®šæ˜¯è°å¤šäº†å­—ç¬¦æˆ–è€…è°å°‘äº†å­—ç¬¦ï¼Œreturn falseã€‚
æœ€åå¦‚æœarræ•°ç»„æ‰€æœ‰å…ƒç´ éƒ½ä¸ºé›¶0ï¼Œè¯´æ˜å­—ç¬¦ä¸²så’Œtæ˜¯å­—æ¯å¼‚ä½è¯ï¼Œreturn trueã€‚
```

### [1002. æŸ¥æ‰¾å…±ç”¨å­—ç¬¦](https://leetcode.cn/problems/find-common-characters/)

```
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ words ï¼Œè¯·ä½ æ‰¾å‡ºæ‰€æœ‰åœ¨ words çš„æ¯ä¸ªå­—ç¬¦ä¸²ä¸­éƒ½å‡ºç°çš„å…±ç”¨å­—ç¬¦ï¼ˆ åŒ…æ‹¬é‡å¤å­—ç¬¦ï¼‰ï¼Œå¹¶ä»¥æ•°ç»„å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚
```

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& words) {
        vector<string> result;
        if(words.size()==0)return result;
        int hash[26] = {0}; // ç”¨æ¥ç»Ÿè®¡æ‰€æœ‰å­—ç¬¦ä¸²é‡Œå­—ç¬¦å‡ºç°çš„æœ€å°é¢‘ç‡
		for (int i = 0; i < A[0].size(); i++) { // ç”¨ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ç»™hashåˆå§‹åŒ–
    		hash[A[0][i] - 'a']++;
			}
        
        int hashOtherStr[26] = {0}; // ç»Ÿè®¡é™¤ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å¤–å­—ç¬¦çš„å‡ºç°é¢‘ç‡
		for (int i = 1; i < A.size(); i++) {
    	memset(hashOtherStr, 0, 26 * sizeof(int));//åˆå§‹åŒ–hashOtherStrï¼Œä¸ºå…¶æ¯ä¸ªå€¼èµ‹å€¼ä¸º1
    	for (int j = 0; j < A[i].size(); j++) {
        hashOtherStr[A[i][j] - 'a']++;
    		}
    	// è¿™æ˜¯å…³é”®æ‰€åœ¨
   		 for (int k = 0; k < 26; k++) { // æ›´æ–°hashï¼Œä¿è¯hashé‡Œç»Ÿè®¡26ä¸ªå­—ç¬¦åœ¨æ‰€æœ‰å­—ç¬¦ä¸²é‡Œå‡ºç°çš„æœ€å°æ¬¡æ•°
       		 hash[k] = min(hash[k], hashOtherStr[k]);
        		}
			}
        for (int i = 0; i < 26; i++) {
            while (hash[i] != 0) { // æ³¨æ„è¿™é‡Œæ˜¯whileï¼Œå¤šä¸ªé‡å¤çš„å­—ç¬¦
                string s(1, i + 'a'); // char -> string
                result.push_back(s);
                hash[i]--;
            }
        }
        return result;
    }
    
};
```

```
æ•´ä½“æ€è·¯å°±æ˜¯ç»Ÿè®¡å‡ºæœç´¢å­—ç¬¦ä¸²é‡Œ26ä¸ªå­—ç¬¦çš„å‡ºç°çš„é¢‘ç‡ï¼Œç„¶åå–æ¯ä¸ªå­—ç¬¦é¢‘ç‡æœ€å°å€¼ï¼Œæœ€åè½¬æˆè¾“å‡ºæ ¼å¼å°±å¯ä»¥äº†ã€‚
```

```python
class Solution:
    def commonChars(self, words: List[str]) -> List[str]:
        tmp = collections.Counter(words[0])
        l = []
        for i in range(1,len(words)):
            # ä½¿ç”¨ & å–äº¤é›†
            tmp = tmp & collections.Counter(words[i])

        # å‰©ä¸‹çš„å°±æ˜¯æ¯ä¸ªå•è¯éƒ½å‡ºç°çš„å­—ç¬¦ï¼ˆé”®ï¼‰ï¼Œä¸ªæ•°ï¼ˆå€¼ï¼‰
        for j in tmp:
            v = tmp[j]
            while(v):
                l.append(j)
                v -= 1
        return l
```



## ç¬¬åä¸€å¤©

### [349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†](https://leetcode.cn/problems/intersection-of-two-arrays/)

```
ç»™å®šä¸¤ä¸ªæ•°ç»„ nums1 å’Œ nums2 ï¼Œè¿”å› å®ƒä»¬çš„äº¤é›† ã€‚è¾“å‡ºç»“æœä¸­çš„æ¯ä¸ªå…ƒç´ ä¸€å®šæ˜¯ å”¯ä¸€ çš„ã€‚æˆ‘ä»¬å¯ä»¥ ä¸è€ƒè™‘è¾“å‡ºç»“æœçš„é¡ºåº ã€‚
```

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result;
        int hash[1001]={0};
        for(int num : nums1){
            hash[num]=1;
        }
        for(int num:nums2){
            if(hash[num]==1){
                result.insert(num);
            }
        }
        return vector<int>(result.begin(),result.end());
    }
};
```

```
æŠŠnums1çš„ç»“æœæ”¾åœ¨hashä¸­ï¼Œå†åˆ¤æ–­nums2ä¸­å‡ºç°hashä¸­çš„æ•°çš„è¯ï¼Œç”¨resultè®°å½•
```

### [202. å¿«ä¹æ•°](https://leetcode.cn/problems/happy-number/)

```
ç¼–å†™ä¸€ä¸ªç®—æ³•æ¥åˆ¤æ–­ä¸€ä¸ªæ•° n æ˜¯ä¸æ˜¯å¿«ä¹æ•°ã€‚

ã€Œå¿«ä¹æ•°ã€Â å®šä¹‰ä¸ºï¼š
å¯¹äºä¸€ä¸ªæ­£æ•´æ•°ï¼Œæ¯ä¸€æ¬¡å°†è¯¥æ•°æ›¿æ¢ä¸ºå®ƒæ¯ä¸ªä½ç½®ä¸Šçš„æ•°å­—çš„å¹³æ–¹å’Œã€‚
ç„¶åé‡å¤è¿™ä¸ªè¿‡ç¨‹ç›´åˆ°è¿™ä¸ªæ•°å˜ä¸º 1ï¼Œä¹Ÿå¯èƒ½æ˜¯ æ— é™å¾ªç¯ ä½†å§‹ç»ˆå˜ä¸åˆ° 1ã€‚
å¦‚æœè¿™ä¸ªè¿‡ç¨‹ ç»“æœä¸ºÂ 1ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å°±æ˜¯å¿«ä¹æ•°ã€‚
å¦‚æœ n æ˜¯ å¿«ä¹æ•° å°±è¿”å› true ï¼›ä¸æ˜¯ï¼Œåˆ™è¿”å› false 
```

```c++
class Solution {
public:
int getSum(n){//æ±‚ä¸€ä¸ªæ•°çš„å„æ•°å¹³æ–¹å’Œ
            int sum=0;
            while(n){
                sum=(n%10)*(n%10);
                n/=10;
            }
            return sum;
        }
    bool isHappy(int n) {
        unordered_set<int> set;
        while(1){
            int sum = getSum(n);
            if(sum==1)return true;
            //å¦‚æœè¿™ä¸ªsumæ›¾ç»å‡ºç°è¿‡
            //è¯´æ˜å·²ç»é™·å…¥äº†æ— é™å¾ªç¯äº†ï¼Œç«‹åˆ»return false
            if(set.find(sum)!=set.end()){
                return false;
            }else{
                set.insert(sum);
            }
            n=sum;
        }
        
    }
};
```

````
ä½¿ç”¨å“ˆå¸Œæ³•ï¼Œæ¥åˆ¤æ–­è¿™ä¸ªsumæ˜¯å¦é‡å¤å‡ºç°ï¼Œå¦‚æœé‡å¤äº†å°±æ˜¯return falseï¼Œ å¦åˆ™ä¸€ç›´æ‰¾åˆ°sumä¸º1ä¸ºæ­¢ã€‚
````

## ç¬¬åäºŒå¤©

### [1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum/)

```
ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ numsÂ å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ targetÂ  çš„é‚£Â ä¸¤ä¸ªÂ æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ åœ¨ç­”æ¡ˆé‡Œä¸èƒ½é‡å¤å‡ºç°ã€‚

ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚
```

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map <int,int> map;
        for(int i = 0; i < nums.size(); i++) {
            // éå†å½“å‰å…ƒç´ ï¼Œå¹¶åœ¨mapä¸­å¯»æ‰¾æ˜¯å¦æœ‰åŒ¹é…çš„key
            auto iter = map.find(target - nums[i]); 
            if(iter != map.end()) {
                return {iter->second, i};
            }
            // å¦‚æœæ²¡æ‰¾åˆ°åŒ¹é…å¯¹ï¼Œå°±æŠŠè®¿é—®è¿‡çš„å…ƒç´ å’Œä¸‹æ ‡åŠ å…¥åˆ°mapä¸­
            map.insert(pair<int, int>(nums[i], i)); 
        }
        return {};
    }
};
```

```
mapç›®çš„ç”¨æ¥å­˜æ”¾æˆ‘ä»¬è®¿é—®è¿‡çš„å…ƒç´ ï¼Œå› ä¸ºéå†æ•°ç»„çš„æ—¶å€™ï¼Œ
éœ€è¦è®°å½•æˆ‘ä»¬ä¹‹å‰éå†è¿‡å“ªäº›å…ƒç´ å’Œå¯¹åº”çš„ä¸‹æ ‡ï¼Œè¿™æ ·æ‰èƒ½æ‰¾åˆ°ä¸å½“å‰å…ƒç´ ç›¸åŒ¹é…çš„ï¼ˆä¹Ÿå°±æ˜¯ç›¸åŠ ç­‰äºtargetï¼‰
æ¥ä¸‹æ¥æ˜¯mapä¸­keyå’Œvalueåˆ†åˆ«è¡¨ç¤ºä»€ä¹ˆã€‚
è¿™é“é¢˜ æˆ‘ä»¬éœ€è¦ ç»™å‡ºä¸€ä¸ªå…ƒç´ ï¼Œåˆ¤æ–­è¿™ä¸ªå…ƒç´ æ˜¯å¦å‡ºç°è¿‡ï¼Œå¦‚æœå‡ºç°è¿‡ï¼Œè¿”å›è¿™ä¸ªå…ƒç´ çš„ä¸‹æ ‡ã€‚
é‚£ä¹ˆåˆ¤æ–­å…ƒç´ æ˜¯å¦å‡ºç°ï¼Œè¿™ä¸ªå…ƒç´ å°±è¦ä½œä¸ºkeyï¼Œæ‰€ä»¥æ•°ç»„ä¸­çš„å…ƒç´ ä½œä¸ºkeyï¼Œæœ‰keyå¯¹åº”çš„å°±æ˜¯valueï¼Œvalueç”¨æ¥å­˜ä¸‹æ ‡ã€‚
æ‰€ä»¥ mapä¸­çš„å­˜å‚¨ç»“æ„ä¸º {keyï¼šæ•°æ®å…ƒç´ ï¼Œvalueï¼šæ•°ç»„å…ƒç´ å¯¹åº”çš„ä¸‹æ ‡}ã€‚
åœ¨éå†æ•°ç»„çš„æ—¶å€™ï¼Œåªéœ€è¦å‘mapå»æŸ¥è¯¢æ˜¯å¦æœ‰å’Œç›®å‰éå†å…ƒç´ åŒ¹é…çš„æ•°å€¼ï¼Œ
å¦‚æœæœ‰ï¼Œå°±æ‰¾åˆ°çš„åŒ¹é…å¯¹ï¼Œå¦‚æœæ²¡æœ‰ï¼Œå°±æŠŠç›®å‰éå†çš„å…ƒç´ æ”¾è¿›mapä¸­ï¼Œå› ä¸ºmapå­˜æ”¾çš„å°±æ˜¯æˆ‘ä»¬è®¿é—®è¿‡çš„å…ƒç´ ã€‚
```

## ç¬¬åä¸‰å¤©

```
éé€’å½’çš„ç»Ÿä¸€è¿­ä»£éå†å’Œé€’å½’éå†
```

```C
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
// äºŒå‰æ ‘é“¾å¼å­˜å‚¨ç»“æ„ä½“
typedef struct Node {
	int data;
	struct Node* left;
	struct Node* right;
} BinaryNode, * BinaryTree;

// åˆå§‹åŒ–äºŒå‰æ ‘
void init(BinaryTree* t) {
	*t = NULL;
}

// åˆ›å»ºæ–°èŠ‚ç‚¹
BinaryNode* createNode(int x) {
	BinaryNode* node = (BinaryNode*)malloc(sizeof(BinaryNode));
	node->data = x;
	node->left = node->right = NULL;
	return node;
}

// é€šè¿‡å…ˆåºéå†åºåˆ—æ„å»ºäºŒå‰æ ‘
void build(BinaryTree* t) {
	int x;
	scanf_s("%d", &x);
	if (x == -1) {  // å½“å‰èŠ‚ç‚¹ä¸ºNULL
		*t = NULL;
	}
	else {  // å½“å‰èŠ‚ç‚¹ä¸ä¸ºNULL
		BinaryNode* node = createNode(x);
		*t = node;
		build(&(node->left));  // é€’å½’æ„å»ºå·¦å­æ ‘
		build(&(node->right));  // é€’å½’æ„å»ºå³å­æ ‘
	}
}

// é€’å½’å®ç°çš„å‰åºéå†
void preRecursionTraversal(BinaryTree t) {
	if (t != NULL) {
		printf("%d ", t->data);
		preRecursionTraversal(t->left);
		preRecursionTraversal(t->right);
	}
}
// é€’å½’å®ç°çš„ä¸­åºéå†
void midRecursionTraversal(BinaryTree t) {
	if (t != NULL) {
		midRecursionTraversal(t->left);
		printf("%d ", t->data);
		midRecursionTraversal(t->right);
	}
}
// é€’å½’å®ç°çš„ååºéå†
void postRecursionTraversal(BinaryTree t) {
	if (t != NULL) {
		postRecursionTraversal(t->left);
		postRecursionTraversal(t->right);
		printf("%d ", t->data);
	}
}


// éé€’å½’å®ç°çš„å‰åºéå†
void preOrderTraversal(BinaryTree* t) {
	// æ£€æŸ¥æ ¹èŠ‚ç‚¹æ˜¯å¦ä¸ºç©ºã€‚
	if (t == NULL) {
		printf("ç©ºæ ‘");
		return;
	}

	//å®šä¹‰æ ˆé¡¶æŒ‡é’ˆå’Œæ•°ç»„
	BinaryNode* stack[MAX_SIZE];
	int top = 0;

	// å°†æ ¹èŠ‚ç‚¹å…¥æ ˆã€‚
	stack[top++] = t;

	// å½“æ ˆéç©ºæ—¶ï¼Œå¾ªç¯æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
	while (top) {
		// å–å‡ºæ ˆé¡¶å…ƒç´ ã€‚
		BinaryNode* node = stack[--top];

		// å¦‚æœå…ƒç´ ä¸ä¸º NULLï¼Œæ‰§è¡Œå¦‚ä¸‹æ“ä½œï¼š
		if (node != NULL) {
			// å¦‚æœå­˜åœ¨å³å­æ ‘ï¼Œå°†å³å­æ ‘å…¥æ ˆ
			if (node->right) stack[top++] = node->right;
			// å¦‚æœå­˜åœ¨å·¦å­æ ‘ï¼Œå°†å·¦å­æ ‘å…¥æ ˆ
			if (node->left) stack[top++] = node->left;

			// å°†å½“å‰èŠ‚ç‚¹å…¥æ ˆ
			stack[top++] = node;
			// å°† NULL å…¥æ ˆï¼Œè¡¨ç¤ºè¯¥èŠ‚ç‚¹å·²ç»éå†è¿‡
			stack[top++] = NULL;
		}
		// å¦‚æœå…ƒç´ ä¸º NULLï¼Œæ‰§è¡Œå¦‚ä¸‹æ“ä½œï¼š
		else {
			// å–å‡ºä¸Šä¸€ä¸ªèŠ‚ç‚¹
			node = stack[--top];
			// æ‰“å°èŠ‚ç‚¹çš„å€¼
			printf("%d ", node->data);
		}
	}
}
// éé€’å½’å®ç°çš„ä¸­åºéå†
void midOrderTraversal(BinaryTree* t) {
	if (t == NULL) {
		printf("ç©ºæ ‘");
		return;
	}

	BinaryNode* stack[MAX_SIZE];
	int top = 0;

	// å°†æ ¹èŠ‚ç‚¹å…¥æ ˆã€‚
	stack[top++] = t;

	while (top) {
		// å–å‡ºæ ˆé¡¶å…ƒç´ ã€‚
		BinaryNode* node = stack[--top];

		if (node != NULL) {
			if (node->right) stack[top++] = node->right;
			stack[top++] = node;
			// å°† NULL å…¥æ ˆï¼Œè¡¨ç¤ºè¯¥èŠ‚ç‚¹å·²ç»éå†è¿‡
			stack[top++] = NULL;
			if (node->left) stack[top++] = node->left;
		}
		// å¦‚æœå…ƒç´ ä¸º NULLï¼Œæ‰§è¡Œå¦‚ä¸‹æ“ä½œï¼š
		else {
			node = stack[--top];
			// æ‰“å°èŠ‚ç‚¹çš„å€¼
			printf("%d ", node->data);
		}
	}
}

// éé€’å½’å®ç°çš„ååºéå†
void postOrderTraversal(BinaryTree t) {
	if (t == NULL) {
		printf("ç©ºæ ‘");
		return;
	}
	BinaryNode* stack[MAX_SIZE];
	int top = 0;

	stack[top++] = t;

	while (top)
	{
		BinaryNode* node = stack[--top];
		if (node != NULL) {
			stack[top++] = node;
			stack[top++] = NULL;

			if (node->right)stack[top++] = node->right;

			if (node->left)stack[top++] = node->left;
		}
		else
		{
			node = stack[--top];
			printf("%d ", node->data);
		}
	}
}
int main() {
	BinaryTree t;
	init(&t);

	printf("è¯·è¾“å…¥å…ˆåºéå†åºåˆ—ï¼Œ-1è¡¨ç¤ºè¯¥ä½ç½®ä¸ºNULL: ");
	build(&t);

	printf("é€’  å½’å®ç°å‰åºéå†ç»“æœ: ");
	preRecursionTraversal(t);
	printf("\n");
	printf("éé€’å½’å®ç°å‰åºéå†ç»“æœ: ");
	preOrderTraversal(t);
	printf("\n");
	printf("é€’  å½’å®ç°ä¸­åºéå†ç»“æœ: ");
	midRecursionTraversal(t);
	printf("\n");
	printf("éé€’å½’å®ç°ä¸­åºéå†ç»“æœ: ");
	midOrderTraversal(t);
	printf("\n");
	printf("é€’  å½’å®ç°ååºéå†ç»“æœ: ");
	postRecursionTraversal(t);
	printf("\n");
	printf("éé€’å½’å®ç°ååºéå†ç»“æœ: ");
	postOrderTraversal(t);
	printf("\n");

	return 0;
}
```

## ç¬¬åå››å¤©

```
å±‚æ¬¡éå†äºŒå‰æ ‘ï¼›
æŒ‰æ»¡äºŒå‰æ ‘æ–¹å¼å»ºç«‹äºŒå‰æ ‘ï¼›
æŒ‰å…ˆåºéå†æ–¹å¼å»ºç«‹äºŒå‰æ ‘ï¼›
æ±‚äºŒå‰æ ‘çš„å¶å­ç»“ç‚¹æ•°ï¼›
æ±‚äºŒå‰æ ‘çš„æ·±åº¦
```

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
// äºŒå‰æ ‘é“¾å¼å­˜å‚¨ç»“æ„ä½“
typedef struct Node {
	int data;
	struct Node* left;
	struct Node* right;
} BinaryNode, * BinaryTree;

// åˆå§‹åŒ–äºŒå‰æ ‘
void init(BinaryTree* t) {
	*t = NULL;
}

// åˆ›å»ºæ–°èŠ‚ç‚¹
BinaryNode* createNode(int x) {
	BinaryNode* node = (BinaryNode*)malloc(sizeof(BinaryNode));
	node->data = x;
	node->left = node->right = NULL;
	return node;
}

// æŒ‰å…ˆåºéå†åºåˆ—æ„å»ºäºŒå‰æ ‘
void build(BinaryTree* t) {
	int x;
	scanf_s("%d", &x);
	if (x == -1) {  // å½“å‰èŠ‚ç‚¹ä¸ºNULL
		*t = NULL;
	}
	else {  // å½“å‰èŠ‚ç‚¹ä¸ä¸ºNULL
		BinaryNode* node = createNode(x);
		*t = node;
		build(&(node->left));  // é€’å½’æ„å»ºå·¦å­æ ‘
		build(&(node->right));  // é€’å½’æ„å»ºå³å­æ ‘
	}
}

// æŒ‰æ»¡äºŒå‰æ ‘æ–¹å¼å»ºç«‹äºŒå‰æ ‘
BinaryNode* build1() {
	BinaryNode * p, * t=NULL, * s[MAX_SIZE];
	char x; int  i, j;
	while (1)
	{
		scanf_s("%d", &i);
		if (i == 0)break;
		else
		{
			x = getchar();
			p = createNode(x);
			s[i] = p;
			if (i == 1) t = p;
			else
			{
				j = i / 2;
				if (i % 2 == 0) s[j]->left = p;
				else s[j]->right = p;
			}
		}
	}
	return t;
}

// äºŒå‰æ ‘çš„å±‚åºéå†
void sequenceTraversal(BinaryTree t,int i) {
	if (t == NULL) {
		printf("ç©ºæ ‘");
		return;
	}
	BinaryNode* queue[MAX_SIZE], * p = t;
	int front = 0, rear = 0;
	if (p != NULL) {
		queue[rear++] = p;
		while (front < rear) {
			p = queue[front++];
			if(i==1)printf("%d ", p->data);
			else printf("%c ", p->data);

			if (p->left != NULL)queue[rear++] = p->left;
			if (p->right != NULL)queue[rear++] = p->right;

		}
	}
}
//æ±‚äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
int maxDepth(BinaryTree t) {
	int depth = 0;
	if (t == NULL) {
		return depth;
	}
	BinaryNode* queue[MAX_SIZE], * p = t;
	int front = 0, rear = 0, level;
	if (t != NULL) {
		queue[rear++] = p;
		level = rear;
		while (front < rear) {
			p = queue[front++];
			if (p->left != NULL)queue[rear++] = p->left;
			if (p->right != NULL)queue[rear++] = p->right;
			if (front == level) {
				depth++;
				level = rear;
			}
		}
	}
	return depth;
}
//æ±‚äºŒå‰æ ‘çš„å¶å­èŠ‚ç‚¹æ•°
int BTreeNum(BinaryTree t) {
	int num = 0;
	if (t == NULL) {
		return num;
	}
	BinaryNode* queue[MAX_SIZE], * p = t;
	int front = 0, rear = 0;
	if (p != NULL) {
		queue[rear++] = p;
		while (front < rear) {
			p = queue[front++];
			if (p->left == NULL && p->right == NULL)num++;
			if (p->left != NULL)queue[rear++] = p->left;
			if (p->right != NULL)queue[rear++] = p->right;

		}
	}
	return num;
}

//1 2 3 -1 -1 4 -1 -1 5 6 -1 -1 -1
int main() {
	BinaryTree t;
	int i = 0;
	init(&t);
	printf("é€‰æ‹©åˆ›å»ºäºŒå‰æ ‘æ–¹å¼ï¼ˆ1ä¸ºå…ˆåºï¼Œ2ä¸ºå±‚åºï¼‰ï¼š");
	scanf_s("%d", &i);
	switch (i)
	{
	case 1:
		printf("è¯·è¾“å…¥å…ˆåºéå†åºåˆ—ï¼Œ-1è¡¨ç¤ºè¯¥ä½ç½®ä¸ºNULL: ");
		build(&t);
		break;
	case 2:
		printf("è¯·è¾“å…¥å±‚åºéå†åºåˆ—ï¼Œ0è¡¨ç¤ºç»“æŸç¤ºä¾‹: \n");
		printf("åºå· å€¼");
		t = build1();
		break;

	default:
		break;
	}
	printf("å±‚åºéå†ç»“æœ: ");
	sequenceTraversal(t,i);
	printf("\n");
	printf("è¯¥æ ‘ä¸€å…±æœ‰%dä¸ªå¶å­èŠ‚ç‚¹.", BTreeNum(t));
	printf("\n");
	printf("è¯¥æ ‘çš„æœ€å¤§æ·±åº¦ä¸º%d.", maxDepth(t));
	return 0;
}
```

## ç¬¬åäº”å¤©

### [454. å››æ•°ç›¸åŠ  II](https://leetcode.cn/problems/4sum-ii/)

```
ç»™ä½ å››ä¸ªæ•´æ•°æ•°ç»„ nums1ã€nums2ã€nums3 å’Œ nums4 ï¼Œ
æ•°ç»„é•¿åº¦éƒ½æ˜¯ n ï¼Œè¯·ä½ è®¡ç®—æœ‰å¤šå°‘ä¸ªå…ƒç»„ (i, j, k, l) èƒ½æ»¡è¶³ï¼š

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
```

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int>umap;//key:a+bçš„å€¼ valueï¼ša+bå€¼å‡ºç°çš„æ¬¡æ•°
        for(int a:nums1){//éå†num1å’Œnum2æ•°ç»„ï¼Œç»Ÿè®¡å‡ºä¸¤ä¸ªæ•°ç»„å…ƒç´ ç›¸åŠ å’Œå€¼å‡ºç°çš„æ¬¡æ•°
            for(int b:nums2){
                umap[a+b]++;//å­˜å‚¨åœ¨unordered_mapä¸­ã€‚ä½¿å¯¹åº”å€¼ï¼ˆa+bï¼‰çš„æ¬¡æ•°++
            }
        }
        int count=0;//ç”¨äºç»Ÿè®¡å››æ•°ç›¸åŠ ä¸º0çš„æ¬¡æ•°
        for(int c:nums3){
            for(int d:nums4){
                if(umap.find(0-(c+d))!=umap.end()){//è¯´æ˜æœ‰å…ƒç´ æ»¡è¶³0+ï¼ˆa+bï¼‰
                count += umap[0-(c+d)];//åˆ™å°†å¯¹åº”å‡ºç°çš„æ¬¡æ•°ï¼ˆvalueï¼ša+b+c+d=0å€¼å‡ºç°çš„æ¬¡æ•°ï¼‰åŠ ç­‰åˆ°è®¡æ•°å™¨ä¸Š
                }
            }
        }
        return count;
    }
};
```

```
1.é¦–å…ˆå®šä¹‰ ä¸€ä¸ªunordered_mapï¼Œkeyæ”¾aå’Œbä¸¤æ•°ä¹‹å’Œï¼Œvalue æ”¾aå’Œbä¸¤æ•°ä¹‹å’Œå‡ºç°çš„æ¬¡æ•°ã€‚
2.éå†å¤§Aå’Œå¤§Bæ•°ç»„ï¼Œç»Ÿè®¡ä¸¤ä¸ªæ•°ç»„å…ƒç´ ä¹‹å’Œï¼Œå’Œå‡ºç°çš„æ¬¡æ•°ï¼Œæ”¾åˆ°mapä¸­ã€‚
3.å®šä¹‰intå˜é‡countï¼Œç”¨æ¥ç»Ÿè®¡ a+b+c+d = 0 å‡ºç°çš„æ¬¡æ•°ã€‚
4.åœ¨éå†å¤§Cå’Œå¤§Dæ•°ç»„ï¼Œæ‰¾åˆ°å¦‚æœ 0-(c+d) åœ¨mapä¸­å‡ºç°è¿‡çš„è¯ï¼Œå°±ç”¨countæŠŠmapä¸­keyå¯¹åº”çš„5.valueä¹Ÿå°±æ˜¯å‡ºç°æ¬¡æ•°ç»Ÿè®¡å‡ºæ¥ã€‚
6.æœ€åè¿”å›ç»Ÿè®¡å€¼ count å°±å¯ä»¥äº†
```

### [383. èµé‡‘ä¿¡](https://leetcode.cn/problems/ransom-note/)

```
ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼šransomNote å’Œ magazine ï¼Œåˆ¤æ–­ ransomNote èƒ½ä¸èƒ½ç”± magazine é‡Œé¢çš„å­—ç¬¦æ„æˆã€‚
å¦‚æœå¯ä»¥ï¼Œè¿”å› true ï¼›å¦åˆ™è¿”å› false ã€‚

magazine ä¸­çš„æ¯ä¸ªå­—ç¬¦åªèƒ½åœ¨ ransomNote ä¸­ä½¿ç”¨ä¸€æ¬¡

æç¤ºï¼šransomNote å’Œ magazine ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ
```

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int rec[26]={0};
        if(magazine.size()<ransomNote.size()){//å¦‚æœmagazineä¸­çš„å­—ç¬¦æ•°å°‘ä¸ransomNoteï¼Œåˆ™ä¸å¯èƒ½å†™å‡ºransomNote
            return false;//æ‰€ä»¥è¿”å›false
        }
        for(int i=0;i<magazine.size();i++){
            rec[magazine[i]-'a']++;//æŠŠmagazineæ•°ç»„ä¸­æ‰€æœ‰å­—ç¬¦å‡ºç°çš„æ¬¡æ•°æŒ‰å¯¹åº”å­—æ¯é¡ºåºå­˜å‚¨åˆ°recä¸­
        }
        for(int j=0;j<ransomNote.size();j++){
            rec[ransomNote[j]-'a']--;//å†å°†ransomNoteä¸­æœ‰çš„å­—ç¬¦ï¼Œåœ¨recä¸­åˆ é™¤

            if(rec[ransomNote[j]-'a']<0){//åœ¨åˆ é™¤çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå°äºé›¶è¯´æ˜ransomNoteé‡Œå‡ºç°çš„å­—ç¬¦ï¼Œmagazineæ²¡æœ‰
                return false;
            }
        }
        return true;
    }
};
```

## ç¬¬åå…­å¤©

### [15. ä¸‰æ•°ä¹‹å’Œ](https://leetcode.cn/problems/3sum/)

```
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸‰å…ƒç»„ [nums[i], nums[j], nums[k]] æ»¡è¶³ i != jã€i != k ä¸” j != k ï¼Œ
åŒæ—¶è¿˜æ»¡è¶³ nums[i] + nums[j] + nums[k] == 0 ã€‚è¯·

ä½ è¿”å›æ‰€æœ‰å’Œä¸º 0 ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚

æ³¨æ„ï¼šç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„ã€‚
```

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());//ä»å°åˆ°å¤§è¿›è¡Œæ’åº

        for(int i=0;i<nums.size();i++){
            if(nums[i]>0) return result;//è¯´æ˜æ‰€æœ‰éƒ½å¤§äº0ã€‚å…¶å’Œä¸å¯èƒ½ä¸º0
            
            if(i>0&&nums[i]==nums[i-1]) continue;//å»é‡,è¿˜æœ‰å› ä¸ºæœ‰i-1çš„æ“ä½œï¼Œæ‰€ä»¥è¦åŠ ä¸€ä¸ªåˆ¤æ–­i>0çš„æ¡ä»¶
            
            int left=i+1;
            int right =nums.size()-1;
            
            while(left<right){//ä¸èƒ½å†™<= ,å› ä¸ºç­‰äºæ—¶å°±æ²¡æœ‰æŒ‡å‘ä¸‰ä¸ªæ•°äº†
                if(nums[i]+nums[right]+nums[left]>0) right--;
                else if(nums[i]+nums[right]+nums[left]<0) left++;
                
                else{ result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                // å»é‡é€»è¾‘åº”è¯¥æ”¾åœ¨æ‰¾åˆ°ä¸€ä¸ªä¸‰å…ƒç»„ä¹‹åï¼Œå¯¹b å’Œ cå»é‡,å› ä¸ºè¦é˜²æ­¢{0ï¼Œ0ï¼Œ0ï¼Œ0ï¼Œ0ï¼Œ0}ä¾‹å¦‚è¿™æ ·çš„nums
                // å¦‚æœæ”¾åœ¨å‰é¢ï¼Œå°†æ”¶é›†ä¸åˆ°ç»“æœ
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // æ‰¾åˆ°ç­”æ¡ˆæ—¶ï¼ŒåŒæŒ‡é’ˆåŒæ—¶æ”¶ç¼©
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
};
```

```
é¦–å…ˆå°†æ•°ç»„æ’åºï¼Œç„¶åæœ‰ä¸€å±‚forå¾ªç¯ï¼Œiä»ä¸‹æ ‡0çš„åœ°æ–¹å¼€å§‹ï¼ŒåŒæ—¶å®šä¸€ä¸ªä¸‹æ ‡left å®šä¹‰åœ¨i+1çš„ä½ç½®ä¸Šï¼Œå®šä¹‰ä¸‹æ ‡right åœ¨æ•°ç»„ç»“å°¾çš„ä½ç½®ä¸Šã€‚
ä¾ç„¶è¿˜æ˜¯åœ¨æ•°ç»„ä¸­æ‰¾åˆ° abc ä½¿å¾—a + b +c =0ï¼Œæˆ‘ä»¬è¿™é‡Œç›¸å½“äº a = nums[i]ï¼Œb = nums[left]ï¼Œc = nums[right]ã€‚
æ¥ä¸‹æ¥å¦‚ä½•ç§»åŠ¨left å’Œrightå‘¢ï¼Œ å¦‚æœnums[i] + nums[left] + nums[right] > 0 å°±è¯´æ˜ æ­¤æ—¶ä¸‰æ•°ä¹‹å’Œå¤§äº†ï¼Œå› ä¸ºæ•°ç»„æ˜¯æ’åºåäº†ï¼Œæ‰€ä»¥rightä¸‹æ ‡å°±åº”è¯¥å‘å·¦ç§»åŠ¨ï¼Œè¿™æ ·æ‰èƒ½è®©ä¸‰æ•°ä¹‹å’Œå°ä¸€äº›ã€‚
å¦‚æœ nums[i] + nums[left] + nums[right] < 0 è¯´æ˜ æ­¤æ—¶ ä¸‰æ•°ä¹‹å’Œå°äº†ï¼Œleft å°±å‘å³ç§»åŠ¨ï¼Œæ‰èƒ½è®©ä¸‰æ•°ä¹‹å’Œå¤§ä¸€äº›ï¼Œç›´åˆ°leftä¸rightç›¸é‡ä¸ºæ­¢ã€‚
```

## ç¬¬åä¸ƒå¤©

### [18. å››æ•°ä¹‹å’Œ](https://leetcode.cn/problems/4sum/)

```
ç»™ä½ ä¸€ä¸ªç”± n ä¸ªæ•´æ•°ç»„æˆçš„æ•°ç»„Â nums ï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼ target ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›æ»¡è¶³ä¸‹è¿°å…¨éƒ¨æ¡ä»¶ä¸”ä¸é‡å¤çš„å››å…ƒç»„Â [nums[a], nums[b], nums[c], nums[d]]Â ï¼ˆè‹¥ä¸¤ä¸ªå››å…ƒç»„å…ƒç´ ä¸€ä¸€å¯¹åº”ï¼Œåˆ™è®¤ä¸ºä¸¤ä¸ªå››å…ƒç»„é‡å¤ï¼‰ï¼š

0 <= a, b, c, dÂ < n
aã€bã€c å’Œ d äº’ä¸ç›¸åŒ
nums[a] + nums[b] + nums[c] + nums[d] == target
ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆ ã€‚
```

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());//ä»å°åˆ°å¤§è¿›è¡Œæ’åº

        for(int i=0;i<nums.size();i++){
            if(nums[i]>target &&(nums[i]>=0)) break;//å‰ªæ
            
            if(i>0&&nums[i]==nums[i-1]) continue;//å»é‡,è¿˜æœ‰å› ä¸ºæœ‰i-1çš„æ“ä½œï¼Œæ‰€ä»¥è¦åŠ ä¸€ä¸ªåˆ¤æ–­i>0çš„æ¡ä»¶
            
            for(int k=i+1;k<nums.size();k++){
                if(nums[i]+nums[k]>target&&nums[i]+nums[k]>=0)break;//å†æ¬¡å‰ªæ

                if(k>i+1&&nums[k]==nums[k-1])continue;// å†æ¬¡å»é‡

                int left=k+1;
                int right =nums.size()-1;
            
                while(left<right){//ä¸èƒ½å†™<= ,å› ä¸ºç­‰äºæ—¶å°±æ²¡æœ‰æŒ‡å‘å››ä¸ªæ•°äº†
                    if((long)nums[i]+nums[right]+nums[left]+nums[k]>target) right--;
                    else if((long)nums[i]+nums[right]+nums[left]+nums[k]<target) left++;
                    
                    else{ result.push_back(vector<int>{nums[i], nums[left], nums[right],nums[k]});
                    // å»é‡é€»è¾‘åº”è¯¥æ”¾åœ¨æ‰¾åˆ°ä¸€ä¸ªå››å…ƒç»„ä¹‹å
                    // å¦‚æœæ”¾åœ¨å‰é¢ï¼Œå°†æ”¶é›†ä¸åˆ°ç»“æœ
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        // æ‰¾åˆ°ç­”æ¡ˆæ—¶ï¼ŒåŒæŒ‡é’ˆåŒæ—¶æ”¶ç¼©
                        right--;
                        left++;
                    }
                }
            }
        }
        return result;
    }
};
```

```
å’Œä¸‰æ•°ä¹‹å’Œæ˜¯ç›¸åŒçš„æ€è·¯ã€‚ä½†æœ‰å¾ˆå¤šä¸åŒçš„ç»†èŠ‚
```

### [344. åè½¬å­—ç¬¦ä¸²](https://leetcode.cn/problems/reverse-string/)

```
ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå…¶ä½œç”¨æ˜¯å°†è¾“å…¥çš„å­—ç¬¦ä¸²åè½¬è¿‡æ¥ã€‚è¾“å…¥å­—ç¬¦ä¸²ä»¥å­—ç¬¦æ•°ç»„ s çš„å½¢å¼ç»™å‡ºã€‚

ä¸è¦ç»™å¦å¤–çš„æ•°ç»„åˆ†é…é¢å¤–çš„ç©ºé—´ï¼Œä½ å¿…é¡»åŸåœ°ä¿®æ”¹è¾“å…¥æ•°ç»„ã€ä½¿ç”¨ O(1) çš„é¢å¤–ç©ºé—´è§£å†³è¿™ä¸€é—®é¢˜ã€‚
```

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0;int right=s.size()-1;
        char temp;
        while(left<right){
            char temp=s[right];
            s[right]=s[left];
            s[left]=temp;
            left++;right--;
        }
    }
};
```

è¿›è¡Œä¸€æ³¢æ”¹é€ ï¼Œé€Ÿåº¦æå‡

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for(int i=0,j=s.size()-1;i<s.size()/2;i++,j--){
            swap(s[i],s[j]);
        }
    }
};
```

```
æ€è·¯å¾ˆç®€å•ï¼Œå°±æ˜¯ä½¿ç”¨åŒæŒ‡é’ˆï¼Œä»ä¸¤ç«¯å‡ºå‘ï¼Œä»¥æ­¤äº¤æ¢
```

### [541. åè½¬å­—ç¬¦ä¸² II](https://leetcode.cn/problems/reverse-string-ii/)

```
ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªæ•´æ•° kï¼Œä»å­—ç¬¦ä¸²å¼€å¤´ç®—èµ·ï¼Œæ¯è®¡æ•°è‡³ 2k ä¸ªå­—ç¬¦ï¼Œå°±åè½¬è¿™ 2k å­—ç¬¦ä¸­çš„å‰ k ä¸ªå­—ç¬¦ã€‚
	å¦‚æœå‰©ä½™å­—ç¬¦å°‘äº k ä¸ªï¼Œåˆ™å°†å‰©ä½™å­—ç¬¦å…¨éƒ¨åè½¬ã€‚
	å¦‚æœå‰©ä½™å­—ç¬¦å°äº 2k ä½†å¤§äºæˆ–ç­‰äº k ä¸ªï¼Œåˆ™åè½¬å‰ k ä¸ªå­—ç¬¦ï¼Œå…¶ä½™å­—ç¬¦ä¿æŒåŸæ ·ã€‚
```

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        for(int i=0;i<s.size();i+=(2*k)){
            if(i+k<s.size()){//å½“å‰ä½ç½®åŠ ä¸Šåè½¬èŒƒå›´å°äºs.size()
            reverse(s.begin()+i,s.begin()+i+k);

            }else{//æŠŠå‰©ä¸‹çš„å…¨éƒ¨åè½¬
                reverse(s.begin()+i,s.end());
            }
        }
        return s;
    }
};
```

```
éå†å­—ç¬¦ä¸²çš„è¿‡ç¨‹ä¸­ï¼Œåªè¦è®© i += (2 * k)ï¼Œi æ¯æ¬¡ç§»åŠ¨ 2 * k å°±å¯ä»¥äº†ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦éœ€è¦æœ‰åè½¬çš„åŒºé—´ã€‚
å› ä¸ºè¦æ‰¾çš„ä¹Ÿå°±æ˜¯æ¯2 * k åŒºé—´çš„èµ·ç‚¹
```

## ç¬¬åå…«å¤©

### [å‰‘æŒ‡ Offer 05. æ›¿æ¢ç©ºæ ¼](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

```
è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼ŒæŠŠå­—ç¬¦ä¸² s ä¸­çš„æ¯ä¸ªç©ºæ ¼æ›¿æ¢æˆ"%20"ã€‚
```

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int count =0; // ç”¨äºç»Ÿè®¡ç©ºæ ¼çš„æ•°ç›®
        int OldSize= s.size();//è®°å½•æ‰©å……å­—ç¬¦ä¸²å‰çš„å­—ç¬¦ä¸²å¤§å°
        for(int i=0;i<s.size();i++){//ç»Ÿè®¡ç©ºæ ¼æ•°
            if(s[i]==' ') count++;
        }
        s.resize(s.size()+count*2);//æ‰©å……å­—ç¬¦ä¸²å¤§å°
        int NewSize= s.size();
        //åˆ©ç”¨åŒæŒ‡é’ˆä»åé¢è¿›è¡Œå¾ªç¯
        for(int i= NewSize-1,j=OldSize-1;j<i;j--,i--){
            if(s[j]!=' ')s[i]=s[j];//åœ¨æŒ‡é’ˆå‘åç§»åŠ¨çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå‰é¢çš„æŒ‡é’ˆä¸ç­‰äºç©ºæ ¼åˆ™å°†å‰é¢çš„å­—ç¬¦å¤åˆ¶çš„åé¢æ¥
            else{
                s[i]='0';
                s[i-1]='2';
                s[i-2]='%';
                i-=2;
            }
        }
        return s;
    }
};
```

```
é¦–å…ˆæ‰©å……æ•°ç»„åˆ°æ¯ä¸ªç©ºæ ¼æ›¿æ¢æˆ"%20"ä¹‹åçš„å¤§å°ã€‚
ç„¶åä»åå‘å‰æ›¿æ¢ç©ºæ ¼ï¼Œä¹Ÿå°±æ˜¯åŒæŒ‡é’ˆæ³•ï¼Œè¿‡ç¨‹å¦‚ä¸‹ï¼š
iæŒ‡å‘æ–°é•¿åº¦çš„æœ«å°¾ï¼ŒjæŒ‡å‘æ—§é•¿åº¦çš„æœ«å°¾
```

### [151. åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯](https://leetcode.cn/problems/reverse-words-in-a-string/)

```
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ åè½¬å­—ç¬¦ä¸²ä¸­ å•è¯ çš„é¡ºåºã€‚

å•è¯ æ˜¯ç”±éç©ºæ ¼å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ã€‚s ä¸­ä½¿ç”¨è‡³å°‘ä¸€ä¸ªç©ºæ ¼å°†å­—ç¬¦ä¸²ä¸­çš„ å•è¯ åˆ†éš”å¼€ã€‚

è¿”å› å•è¯ é¡ºåºé¢ å€’ä¸” å•è¯ ä¹‹é—´ç”¨å•ä¸ªç©ºæ ¼è¿æ¥çš„ç»“æœå­—ç¬¦ä¸²ã€‚

æ³¨æ„ï¼šè¾“å…¥å­—ç¬¦ä¸² sä¸­å¯èƒ½ä¼šå­˜åœ¨å‰å¯¼ç©ºæ ¼ã€å°¾éšç©ºæ ¼æˆ–è€…å•è¯é—´çš„å¤šä¸ªç©ºæ ¼ã€‚è¿”å›çš„ç»“æœå­—ç¬¦ä¸²ä¸­ï¼Œå•è¯é—´åº”å½“ä»…ç”¨å•ä¸ªç©ºæ ¼åˆ†éš”ï¼Œä¸”ä¸åŒ…å«ä»»ä½•é¢å¤–çš„ç©ºæ ¼ã€‚
```

```c++
class Solution {
public:
    void reverse(string& s, int start, int end){ //ç¿»è½¬ï¼ŒåŒºé—´å†™æ³•ï¼šå·¦é—­å³é—­ []
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }
      void removeExtraSpaces(string& s) {//å»é™¤æ‰€æœ‰ç©ºæ ¼å¹¶åœ¨ç›¸é‚»å•è¯ä¹‹é—´æ·»åŠ ç©ºæ ¼, å¿«æ…¢æŒ‡é’ˆã€‚
        int slow = 0;  
        for (int i = 0; i < s.size(); ++i) { //
            if (s[i] != ' ') { //é‡åˆ°éç©ºæ ¼å°±å¤„ç†ï¼Œå³åˆ é™¤æ‰€æœ‰ç©ºæ ¼ã€‚
                if (slow != 0) s[slow++] = ' '; //æ‰‹åŠ¨æ§åˆ¶ç©ºæ ¼ï¼Œç»™å•è¯ä¹‹é—´æ·»åŠ ç©ºæ ¼ã€‚slow != 0è¯´æ˜ä¸æ˜¯ç¬¬ä¸€ä¸ªå•è¯ï¼Œéœ€è¦åœ¨å•è¯å‰æ·»åŠ ç©ºæ ¼ã€‚
                while (i < s.size() && s[i] != ' ') { //è¡¥ä¸Šè¯¥å•è¯ï¼Œé‡åˆ°ç©ºæ ¼è¯´æ˜å•è¯ç»“æŸã€‚
                    s[slow++] = s[i++];
                }
            }
        }
        s.resize(slow); //slowçš„å¤§å°å³ä¸ºå»é™¤å¤šä½™ç©ºæ ¼åçš„å¤§å°ã€‚
    }

    string reverseWords(string s) {
        removeExtraSpaces(s); //å»é™¤å¤šä½™ç©ºæ ¼ï¼Œä¿è¯å•è¯ä¹‹é—´ä¹‹åªæœ‰ä¸€ä¸ªç©ºæ ¼ï¼Œä¸”å­—ç¬¦ä¸²é¦–å°¾æ²¡ç©ºæ ¼ã€‚
        reverse(s, 0, s.size() - 1);
        int start = 0; //removeExtraSpacesåä¿è¯ç¬¬ä¸€ä¸ªå•è¯çš„å¼€å§‹ä¸‹æ ‡ä¸€å®šæ˜¯0ã€‚
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') { //åˆ°è¾¾ç©ºæ ¼æˆ–è€…ä¸²å°¾ï¼Œè¯´æ˜ä¸€ä¸ªå•è¯ç»“æŸã€‚è¿›è¡Œç¿»è½¬ã€‚
                reverse(s, start, i - 1); //ç¿»è½¬ï¼Œæ³¨æ„æ˜¯å·¦é—­å³é—­ []çš„ç¿»è½¬ã€‚
                start = i + 1; //æ›´æ–°ä¸‹ä¸€ä¸ªå•è¯çš„å¼€å§‹ä¸‹æ ‡start
            }
        }
        return s;
    }
};
```

```
å®šä¹‰ä¸€ä¸ª removeExtraSpaces å‡½æ•°ï¼Œè¯¥å‡½æ•°çš„ä½œç”¨æ˜¯å»é™¤å­—ç¬¦ä¸²ä¸­çš„å¤šä½™ç©º
æ ¼ï¼Œå¹¶åœ¨ç›¸é‚»å•è¯ä¹‹é—´æ·»åŠ ä¸€ä¸ªç©ºæ ¼ã€‚å…·ä½“å®ç°æ–¹å¼ä¸ºä½¿ç”¨å¿«æ…¢æŒ‡é’ˆéå†æ•´ä¸ªå­—ç¬¦
ä¸²ï¼Œå¿«æŒ‡é’ˆæŒ‡å‘å½“å‰å¤„ç†çš„å­—ç¬¦ï¼Œæ…¢æŒ‡é’ˆæŒ‡å‘å¯ä»¥æ’å…¥ç©ºæ ¼çš„ä½ç½®ï¼Œå½“é‡åˆ°ä¸€ä¸ªé
ç©ºæ ¼å­—ç¬¦æ—¶ï¼Œå°†å…¶æ’å…¥åˆ°æ…¢æŒ‡é’ˆæ‰€æŒ‡å‘çš„ä½ç½®ï¼ŒåŒæ—¶åœ¨ç›¸é‚»å•è¯ä¹‹é—´æ·»åŠ ä¸€ä¸ªç©º
æ ¼ã€‚æœ€åä½¿ç”¨ resize å‡½æ•°å°†å­—ç¬¦ä¸²çš„é•¿åº¦æ”¹ä¸ºå»é™¤å¤šä½™ç©ºæ ¼åçš„é•¿åº¦ã€‚

å®šä¹‰ä¸€ä¸ª reverse å‡½æ•°ï¼Œè¯¥å‡½æ•°çš„ä½œç”¨æ˜¯å°†ä¸€ä¸ªå­—ç¬¦ä¸²çš„æŒ‡å®šåŒºé—´ç¿»è½¬ã€‚å…·ä½“å®ç°æ–¹å¼ä¸ºä½¿ç”¨åŒæŒ‡é’ˆï¼Œåˆ†åˆ«ä»åŒºé—´çš„ä¸¤ç«¯å¼€å§‹å‘ä¸­é—´éå†ï¼Œäº¤æ¢ä¸¤ä¸ªæŒ‡é’ˆæ‰€æŒ‡å‘çš„å­—ç¬¦ã€‚

è°ƒç”¨ removeExtraSpaces å‡½æ•°å»é™¤å­—ç¬¦ä¸²ä¸­çš„å¤šä½™ç©ºæ ¼ã€‚

è°ƒç”¨ reverse å‡½æ•°å°†æ•´ä¸ªå­—ç¬¦ä¸²ç¿»è½¬ã€‚

ä½¿ç”¨åŒæŒ‡é’ˆéå†æ•´ä¸ªå­—ç¬¦ä¸²ï¼Œå½“é‡åˆ°ä¸€ä¸ªç©ºæ ¼æˆ–å­—ç¬¦ä¸²ç»“å°¾æ—¶ï¼Œè¯´æ˜ä¸€ä¸ªå•è¯ç»“æŸï¼Œè°ƒç”¨ reverse å‡½æ•°å°†è¯¥å•è¯ç¿»è½¬ï¼Œç„¶åç»§ç»­éå†ä¸‹ä¸€ä¸ªå•è¯ã€‚

è¿”å›ç¿»è½¬åçš„å­—ç¬¦ä¸²
```

## ç¬¬åä¹å¤©

### [å‰‘æŒ‡ Offer 58 - II. å·¦æ—‹è½¬å­—ç¬¦ä¸²](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```
å­—ç¬¦ä¸²çš„å·¦æ—‹è½¬æ“ä½œæ˜¯æŠŠå­—ç¬¦ä¸²å‰é¢çš„è‹¥å¹²ä¸ªå­—ç¬¦è½¬ç§»åˆ°å­—ç¬¦ä¸²çš„å°¾éƒ¨ã€‚è¯·å®šä¹‰ä¸€ä¸ªå‡½æ•°å®ç°å­—ç¬¦ä¸²å·¦æ—‹è½¬æ“ä½œçš„åŠŸèƒ½ã€‚æ¯”å¦‚ï¼Œè¾“å…¥å­—ç¬¦ä¸²"abcdefg"å’Œæ•°å­—2ï¼Œè¯¥å‡½æ•°å°†è¿”å›å·¦æ—‹è½¬ä¸¤ä½å¾—åˆ°çš„ç»“æœ"cdefgab"ã€‚
```

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(),s.begin()+n);//åè½¬å‰nä¸ª
        reverse(s.begin()+n,s.end());//åè½¬å‰©ä¸‹çš„
        reverse(s.begin(),s.end());//å†åè½¬æ‰€æœ‰
        return s;
    }
};
```

```
å¾ˆå®¹æ˜“ç†è§£

```

##  ç¬¬äºŒåå¤©

### [28. æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ä¸‹æ ‡](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

```
ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²Â haystack å’Œ needle ï¼Œè¯·ä½ åœ¨ haystack å­—ç¬¦ä¸²ä¸­æ‰¾å‡º needle å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ä¸‹æ ‡ï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ã€‚å¦‚æœÂ needle ä¸æ˜¯ haystack çš„ä¸€éƒ¨åˆ†ï¼Œåˆ™è¿”å›Â  -1 ã€‚
```

```c++
class Solution {
public:
    // è®¡ç®—æ¨¡å¼ä¸²çš„nextæ•°ç»„
    void getNext(int* next, const string& s) {
        int i = 0, j = -1;
        int plen = s.size();
        next[0] = -1;
        while (i < plen - 1) {  // æ³¨æ„å¾ªç¯æ¡ä»¶æ˜¯i<plen-1è€Œä¸æ˜¯i<plen
            if (j == -1 || s[i] == s[j]) {
                i++;
                j++;
                next[i] = j;
            } else {
                j = next[j];
            }
        }
    }

    // åœ¨æ–‡æœ¬ä¸²ä¸­æŸ¥æ‰¾æ¨¡å¼ä¸²çš„ä½ç½®
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);  // è®¡ç®—æ¨¡å¼ä¸²çš„nextæ•°ç»„
        int haylen = haystack.size();
        int needlen = needle.size();
        int i = 0, j = 0;
        while (i < haylen && j < needlen) {
            if (j == -1 || haystack[i] == needle[j]) {
                i++;
                j++;
            } else {
                j = next[j];  // ç§»åŠ¨æ¨¡å¼ä¸²ï¼Œç»§ç»­åŒ¹é…
            }
        }
        if (j == needlen) {  // åŒ¹é…æˆåŠŸï¼Œè¿”å›æ¨¡å¼ä¸²åœ¨æ–‡æœ¬ä¸²ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
            return i - j;
        }
        return -1;  // åŒ¹é…å¤±è´¥
    }
};
```

```
ç»å…¸çš„KMPç®—æ³•
```

## ç¬¬äºŒåä¸€å¤©

###  [459. é‡å¤çš„å­å­—ç¬¦ä¸²](https://leetcode.cn/problems/repeated-substring-pattern/)

```
ç»™å®šä¸€ä¸ªéç©ºçš„å­—ç¬¦ä¸² s ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥é€šè¿‡ç”±å®ƒçš„ä¸€ä¸ªå­ä¸²é‡å¤å¤šæ¬¡æ„æˆ
```

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        return (s+s).find(s,1)!=s.size();
    }
};
```

```
ç•™
ç©º 

ç”¨
äº
å†™
KMP
æ–¹
æ³•
```

### [232. ç”¨æ ˆå®ç°é˜Ÿåˆ—](https://leetcode.cn/problems/implement-queue-using-stacks/)

```
è¯·ä½ ä»…ä½¿ç”¨ä¸¤ä¸ªæ ˆå®ç°å…ˆå…¥å…ˆå‡ºé˜Ÿåˆ—ã€‚é˜Ÿåˆ—åº”å½“æ”¯æŒä¸€èˆ¬é˜Ÿåˆ—æ”¯æŒçš„æ‰€æœ‰æ“ä½œï¼ˆpushã€popã€peekã€emptyï¼‰ï¼š

å®ç° MyQueue ç±»ï¼š

void push(int x) å°†å…ƒç´  x æ¨åˆ°é˜Ÿåˆ—çš„æœ«å°¾
int pop() ä»é˜Ÿåˆ—çš„å¼€å¤´ç§»é™¤å¹¶è¿”å›å…ƒç´ 
int peek() è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ 
boolean empty() å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false
```

```c++
class MyQueue {
public:
    stack<int> StIn;//è¾“å…¥æ ˆ
    stack<int> StOut;//è¾“å‡ºæ ˆ
    MyQueue() {

    }
    
    void push(int x) {//å…¥é˜Ÿ
        StIn.push(x);//å°†å…ƒç´ åŠ å…¥è¾“å…¥æ ˆ
    }
    
    int pop() {//è¾“å‡ºå…ƒç´ ï¼Œå¹¶åˆ é™¤é˜Ÿä¸­å…ƒç´ 
        if(StOut.empty()){//åˆ¤æ–­è¾“å‡ºæ ˆæ˜¯å¦ä¸ºç©º
            while(!StIn.empty()){//å¦‚æœä¸ºç©ºï¼Œå°±å°†è¾“å…¥æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œè¾“å‡ºåˆ°è¾“å‡ºæ ˆä¸­
                StOut.push(StIn.top());//å°†é¡¶éƒ¨å…ƒç´ åŠ å…¥åˆ°è¾“å‡ºæ ˆä¸­
                StIn.pop();//ä¸Šä¸€æ­¥åªæ˜¯å–åˆ°topï¼Œæ²¡æœ‰åˆ é™¤ï¼Œåœ¨è¿™ä¸€æ­¥åˆ é™¤
            }
        }
         int a = StOut.top();
         StOut.pop();
        return a;//å–å‡ºï¼Œåˆ é™¤ï¼Œè¿”å›
    }
    
    int peek() {//å®ç°å–å‡ºå…ƒç´ ï¼Œä½†ä¸åˆ é™¤
        int a=this->pop();//å°†å…ƒç´ å¼¹å‡ºæ¥äº†
        StOut.push(a);//åœ¨åŠ å›å»
        return a;

    }
    
    bool empty() {//åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
        return StIn.empty()&&StOut.empty();//ä¸¤ä¸ªæ ˆéƒ½ä¸ºç©ºæ—¶ï¼Œé˜Ÿåˆ—å°±ä¸ºç©ºäº†
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



